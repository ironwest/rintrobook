{
  "hash": "b5fff74edba39bee95b1577d0adad318",
  "result": {
    "markdown": "---\ntitle: group_byでの集計\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nid <- 1:15\n\nage <- c(30,40,65,34,86,\n         43,64,26,87,45,\n         76,24,97,45,34)\n\ngender <- c(\"f\",\"m\",\"f\",\"f\",\"f\",\n            \"m\",\"m\",\"f\",\"f\",\"m\",\n            \"f\",\"f\",\"m\",\"m\",\"m\")\n\nisx <- c(F,T,F,F,T,\n         T,T,F,T,F,\n         T,F,F,F,T)\n\ndat <- tibble(id     = id    , age = age, \n              gender = gender, isx = isx)\n```\n:::\n\n\n\nひとつ前の動画での課題、やってみましたか？次のようなスクリプトができているば、こちらが意図していた通りとなります。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  group_by(isx) %>% \n  summarise(\n    age_mean = mean(age),\n    age_min  = min(age),\n    age_max  = max(age),\n    gender_m_n  = sum(gender==\"m\"),\n    gender_m_p  = 100*gender_m_n/n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 6\n  isx   age_mean age_min age_max gender_m_n gender_m_p\n  <lgl>    <dbl>   <dbl>   <dbl>      <int>      <dbl>\n1 FALSE     45.8      24      97          3       37.5\n2 TRUE      61.4      34      87          4       57.1\n```\n:::\n:::\n\n\n\nところで、集団で「ない」集計のときに集計した結果を表示するスクリプトを再度記載してみます\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- tibble(id     = id, \n              age    = age, \n              gender = gender, \n              isx    = isx   ) %>%\n  \n  summarise(age_mean = mean(age),\n            age_min = min(age),\n            age_max = max(age),\n            gender_male_n  = sum(gender==\"m\"),\n            gender_male_p  = 100*gender_male_n/n() ) %>% \n  \n  mutate(across(everything(), ~{format(.,nsmall=1, digits=1)}))　%>% \n  \n  mutate(\n    `年齢(最小-最大)` = str_c(age_mean,\"(\",age_min,\"-\",age_max,\")\"),\n    `性別:男性(%)`  = str_c(gender_male_n,\"(\",gender_male_p,\")\")\n  ) %>%\n  \n  select(matches(\"^年齢|^性別\")) %>% \n  \n  pivot_longer(everything(),\n               names_to = \" \",\n               values_to = \"全体\")\n  \nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 2\n  ` `             全体           \n  <chr>           <chr>          \n1 年齢(最小-最大) 53.1(24.0-97.0)\n2 性別:男性(%)    7(46.7)        \n```\n:::\n:::\n\n\n\nこれの、summariseの手前にgroup_by(isx)をいれて、select()以降を除去して実行してみましょう。また、across関数の部分では、isxはロジカル型のままで残しておきたい(文字列に変更する必要がない)ので、.colsで省いておきます\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres2 <- \ntibble(id     = id, \n       age    = age, \n       gender = gender, \n       isx    = isx   ) %>%\n  group_by(isx) %>%  #これを足した\n  summarise(age_mean = mean(age),\n            age_min = min(age),\n            age_max = max(age),\n            gender_male_n  = sum(gender==\"m\"),\n            gender_male_p  = 100*gender_male_n/n() ) %>% \n  mutate(\n    across(\n      .cols=!isx, #isxは変換しない。\n      ~{format(.,nsmall=1, digits=1)}\n    )\n  )　%>% \n  mutate(\n    `年齢(最小-最大)` = str_c(age_mean,\"(\",age_min,\"-\",age_max,\")\"),\n    `性別:男性(%)`  = str_c(gender_male_n,\"(\",gender_male_p,\")\")\n  ) \n\nView(res2)\n```\n:::\n\n\n\nいかがでしょうか？isx毎に、最初に作った集計がうまくできていることが確認できますね？\n\nあとは、この結果をうまく最終的に表示したい\n\n|               | 購入あり | 購入なし|\n|:=============:|:========:|:=======:|\n|年齢(最小-最大)|  ~~~~~~  | ~~~~~~~ |\n|性別:男性(%)   |  ~~~~~~  | ~~~~~~~ |\n\nこんな形に持っていくことができたら最初の目標である、グループ集計の完成です。\n\nできますか?今表示されているこの結果から、この表の形になるように動画をとめて実行してみてください。pivot_longerとpivot_widerを1回ずつ使うとその形にできます\n\nやってみましょう。\n\nまず必要な列のみに絞り込んでおきます。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres2 %>% \n  select(isx, matches(\"^年齢|^性別\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  isx   `年齢(最小-最大)` `性別:男性(%)`\n  <lgl> <chr>             <chr>         \n1 FALSE 45.8(24.0-97.0)   3(37.5)       \n2 TRUE  61.4(34.0-87.0)   4(57.1)       \n```\n:::\n:::\n\n\n\nこんな感じですね。\n\nそれで、pivot_longerで一度縦持ちデータに変換しましょう\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres2 %>% \n  select(isx, matches(\"^年齢|^性別\")) %>% \n  pivot_longer(cols=!isx,names_to=\"name\",values_to=\"value\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 3\n  isx   name            value          \n  <lgl> <chr>           <chr>          \n1 FALSE 年齢(最小-最大) 45.8(24.0-97.0)\n2 FALSE 性別:男性(%)    3(37.5)        \n3 TRUE  年齢(最小-最大) 61.4(34.0-87.0)\n4 TRUE  性別:男性(%)    4(57.1)        \n```\n:::\n:::\n\n\n\n後は、このデータをisxを横方向に広げてあげるとよいので\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres2 %>% \n  select(isx, matches(\"^年齢|^性別\")) %>% \n  pivot_longer(cols=!isx,names_to=\"name\",values_to=\"value\") %>% \n  pivot_wider(id_cols=name, names_from=isx, values_from=value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  name            `FALSE`         `TRUE`         \n  <chr>           <chr>           <chr>          \n1 年齢(最小-最大) 45.8(24.0-97.0) 61.4(34.0-87.0)\n2 性別:男性(%)    3(37.5)         4(57.1)        \n```\n:::\n:::\n\n\n\n良い感じですね?\n\n後は、名前を変更しつつ並び替えてみましょう\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres2 %>% \n  select(isx, matches(\"^年齢|^性別\")) %>% \n  pivot_longer(cols=!isx,names_to=\"name\",values_to=\"value\") %>% \n  pivot_wider(id_cols=name, names_from=isx, values_from=value) %>% \n  select(` ` = name, `購買あり`=`TRUE`, `購買なし`=`FALSE`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  ` `             購買あり        購買なし       \n  <chr>           <chr>           <chr>          \n1 年齢(最小-最大) 61.4(34.0-87.0) 45.8(24.0-97.0)\n2 性別:男性(%)    4(57.1)         3(37.5)        \n```\n:::\n:::\n\n\n\nできあがりました!\n\nお疲れさまでした。\n\nここまでで、dplyrのみを使って集計して、表を作成することにとりくんできました。\n\ngroup_by関数やacross関数の使い方を解説するため、「めんどうな方法」をあえてここではお示ししています。\n\n次の動画からは、group_by関数の使い方を実例をご提示しながら解説していきます。\n\n",
    "supporting": [
      "s06-016_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}