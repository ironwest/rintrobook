{
  "hash": "c4bcf0fec40b4e91ee293c3d3602a89c",
  "result": {
    "markdown": "---\ntitle: :時間の集計4 Rで実施1(sld126)\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(lubridate)\ndat <- read_csv(\"data/time.csv\")\n```\n:::\n\n\n\nまず、このデータ、選んだIDを図示してみます。\n\n(解説のための図なので、スクリプトの内容は解説しません)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_id <- function(.data,tgt_id){\n  gdat <- .data %>% \n    filter(id %in% tgt_id) %>% \n    mutate(row_n = n():1) %>%\n    mutate(points = map2(start,end, ~{.x:.y})) %>% \n    select(id,med,row_n,points) %>% \n    unnest(c(points)) %>% \n    mutate(points = as_date(points))\n  \n  ggplot(gdat) +\n    geom_point(aes(x = points, y = as.factor(row_n), color = med)) +\n    scale_y_discrete(labels=NULL) +\n    facet_wrap(~id, scales = \"free\")\n}\n```\n:::\n\n\n\nこのplot_id関数、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_id(dat,c(1,15,20))\n```\n\n::: {.cell-output-display}\n![](s06-032_files/figure-pdf/unnamed-chunk-3-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nこんな感じで、x軸に日付、y軸に行として、点で処方期間を描画してくれています。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% filter(id ==20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 4\n     id med   start      end       \n  <dbl> <chr> <date>     <date>    \n1    20 B     2020-05-06 2020-08-10\n2    20 C     2020-05-22 2020-07-20\n3    20 C     2020-04-28 2020-07-21\n```\n:::\n:::\n\n\n\nここで、課題としては、例えばid20番の青色の点、薬Cの投与期間が重複しているため、これを1つの期間としてまとめたいという形です。\n\nデータで、2行より多く行数があるidを抜き出しておきましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nid_with_gt2r <- dat %>% \n  count(id) %>% \n  filter(n > 2) %>% \n  pull(id)\n\nid_with_gt2r\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]   5  13  15  16  20  22  23  29  35  36  39  40  45  48  49  57  58  59  62\n[20]  66  67  68  75  77  80  81  82  85  86  89  92  93  99 104 108 113 119 125\n[39] 128 131 132 140 141 146 147 151 152 159 168 170 173 174 184 187 188 189 192\n[58] 194 195 196 200\n```\n:::\n:::\n\n\n\nこれは\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% count(id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 200 x 2\n      id     n\n   <dbl> <int>\n 1     1     2\n 2     2     2\n 3     3     1\n 4     4     1\n 5     5     3\n 6     6     2\n 7     7     1\n 8     8     1\n 9     9     1\n10    10     2\n# i 190 more rows\n```\n:::\n:::\n\n\n\nで、idの数をそれぞれ数えて、nが2より大きいものだけにしぼりこんで、pull関数でベクトルとしてidを抜き出しています。実際にどのようなデータがあるか確認しておきます\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_id(dat,id_with_gt2r[1:9])\n```\n\n::: {.cell-output-display}\n![](s06-032_files/figure-pdf/unnamed-chunk-7-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot_id(dat,id_with_gt2r[10:18]) \n```\n\n::: {.cell-output-display}\n![](s06-032_files/figure-pdf/unnamed-chunk-7-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot_id(dat,id_with_gt2r[19:27]) \n```\n\n::: {.cell-output-display}\n![](s06-032_files/figure-pdf/unnamed-chunk-7-3.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot_id(dat,id_with_gt2r[28:36]) \n```\n\n::: {.cell-output-display}\n![](s06-032_files/figure-pdf/unnamed-chunk-7-4.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot_id(dat,id_with_gt2r[37:45]) \n```\n\n::: {.cell-output-display}\n![](s06-032_files/figure-pdf/unnamed-chunk-7-5.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot_id(dat,id_with_gt2r[46:54]) \n```\n\n::: {.cell-output-display}\n![](s06-032_files/figure-pdf/unnamed-chunk-7-6.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot_id(dat,id_with_gt2r[55:61])\n```\n\n::: {.cell-output-display}\n![](s06-032_files/figure-pdf/unnamed-chunk-7-7.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nそれでは、スライドでお示ししたスクリプトで処理を行っていきましょう\n\nここでは、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_id(dat,id_with_gt2r[11])\n```\n\n::: {.cell-output-display}\n![](s06-032_files/figure-pdf/unnamed-chunk-8-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nこのデータをきれいにすることをまずは考えます。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp <- dat %>% \n  filter(id == 39) %>% \n  select(start,end)\n```\n:::\n\n\n\nID39 は薬剤Cについて３つの期間が含まれるデータなので、スライドでの解説で行った形のデータになっています。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp %>% \n  arrange(start) %>% #並びかえて \n  mutate(interv = interval(start, end)) %>% #intervalを作成して \n  mutate(\n    prev_overlap = int_overlaps(interv, lag(interv)),\n    prev_nextday = int_overlaps(interv, int_shift(lag(interv),days(1))),\n  ) %>% #期間の重なりを確認\n  mutate(prev_oa = prev_overlap | prev_nextday) %>% #２条件を１つにまとめて \n  replace_na(list(prev_oa = FALSE)) %>% #欠損はFALSEで置き換え\n  mutate(presc_id = cumsum(!prev_oa)) %>% #TRUE FALSEをひっくり返して累積和\n  group_by(presc_id) %>%  # 累積和（塊）毎にグループを作って\n  summarise(start = min(start), end = max(end)) # 各グループの最小・最大で集計する\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  presc_id start      end       \n     <int> <date>     <date>    \n1        1 2020-04-27 2020-05-01\n2        2 2020-05-08 2020-06-04\n```\n:::\n:::\n\n\n\nと、こんな感じでうまく、５月１日までの塊と、５月８日移行の塊に分けることができました。\n\nこの処理、同じIDの同じ薬内での処理になっていますが、これを別々のIDと薬剤に処理してあげる必要があります。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_id(dat,id_with_gt2r[1:8])\n```\n\n::: {.cell-output-display}\n![](s06-032_files/figure-pdf/unnamed-chunk-11-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n上で書いたスクリプトは、それぞれのID内で、同じ薬剤での処理となります。\n\nここで課題です。上のスクリプトを利用して、ID毎、ID毎の薬剤毎に上のスクリプトを適応する処理を書くことはできますか？\n\n次の動画でIDと薬剤を加味したスクリプトを解説していきますが、できればまずご自身で可能か、取り組んでみてください。\n\n",
    "supporting": [
      "s06-032_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}