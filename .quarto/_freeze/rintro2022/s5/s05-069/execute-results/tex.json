{
  "hash": "2266e44d6c892fadb17a178525a7c57a",
  "result": {
    "markdown": "---\ntitle: 実践 left_join\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\nそれでは、left_join、実践していきましょう。\n\nまずスライドで利用していたデータを作っておきます。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\ndat <- tribble(\n  ~date　　 , ~patient_id, ~kensa_id, ~value,\n  \"2020/4/1\", 1          , \"a342\"   , 6.8   ,\n  \"2020/4/1\", 2          , \"a342\"   , 5.6   ,\n  \"2020/4/2\", 1          , \"a341\"   , 52    ,\n  \"2020/4/2\", 3          , \"a340\"   , 32\n)\n```\n:::\n\n\n\nここで利用しているtribble関数、チルダ列名とかいて、その後、データを入力することで「表の形」そのままでtibbleが作れるので、こういう風に、データの位置を考えながら表を作成しないといけないときに結構便利です。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkensa <- tribble(\n  ~kensa_id, ~kensa_name, ~unit,\n  \"a340\"   , \"AST\"      , \"IU\"       ,\n  \"a341\"   , \"ALT\"      , \"IU\"       ,\n  \"a342\"   , \"HbA1c\"    , \"%\"         \n)\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 4\n  date     patient_id kensa_id value\n  <chr>         <dbl> <chr>    <dbl>\n1 2020/4/1          1 a342       6.8\n2 2020/4/1          2 a342       5.6\n3 2020/4/2          1 a341      52  \n4 2020/4/2          3 a340      32  \n```\n:::\n\n```{.r .cell-code}\nkensa\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 3\n  kensa_id kensa_name unit \n  <chr>    <chr>      <chr>\n1 a340     AST        IU   \n2 a341     ALT        IU   \n3 a342     HbA1c      %    \n```\n:::\n:::\n\n\n\nまず、これらのデータを結合していきましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(dat, kensa, by = \"kensa_id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 6\n  date     patient_id kensa_id value kensa_name unit \n  <chr>         <dbl> <chr>    <dbl> <chr>      <chr>\n1 2020/4/1          1 a342       6.8 HbA1c      %    \n2 2020/4/1          2 a342       5.6 HbA1c      %    \n3 2020/4/2          1 a341      52   ALT        IU   \n4 2020/4/2          3 a340      32   AST        IU   \n```\n:::\n:::\n\n\n\nできました!\n\nパイプ関数を利用するのであれば、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  left_join(kensa, by = \"kensa_id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 6\n  date     patient_id kensa_id value kensa_name unit \n  <chr>         <dbl> <chr>    <dbl> <chr>      <chr>\n1 2020/4/1          1 a342       6.8 HbA1c      %    \n2 2020/4/1          2 a342       5.6 HbA1c      %    \n3 2020/4/2          1 a341      52   ALT        IU   \n4 2020/4/2          3 a340      32   AST        IU   \n```\n:::\n:::\n\n\n\nでもOKです。パイプは一つ目のアーギュメントとして扱われるので、左側の表　 %>% 　left_join(右側の表...)となっている必要があることに注意が必要です。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkensa2 <- kensa %>% rename(id = kensa_id)\n\nkensa2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 3\n  id    kensa_name unit \n  <chr> <chr>      <chr>\n1 a340  AST        IU   \n2 a341  ALT        IU   \n3 a342  HbA1c      %    \n```\n:::\n:::\n\n\n\nここで、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"date\"       \"patient_id\" \"kensa_id\"   \"value\"     \n```\n:::\n\n```{.r .cell-code}\ncolnames(kensa2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"id\"         \"kensa_name\" \"unit\"      \n```\n:::\n:::\n\n\n\n左と、右の表の結合したい列の名前が違う場合も処理しておきましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  left_join(kensa2, by=\"kensa_id\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `left_join()`:\n! Join columns in `y` must be present in the data.\nx Problem with `kensa_id`.\n```\n:::\n:::\n\n\n\nだと、右側にkensa_idという名前の列がないのでエラーになります。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  left_join(kensa2, by=c(\"kensa_id\"=\"id\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 6\n  date     patient_id kensa_id value kensa_name unit \n  <chr>         <dbl> <chr>    <dbl> <chr>      <chr>\n1 2020/4/1          1 a342       6.8 HbA1c      %    \n2 2020/4/1          2 a342       5.6 HbA1c      %    \n3 2020/4/2          1 a341      52   ALT        IU   \n4 2020/4/2          3 a340      32   AST        IU   \n```\n:::\n:::\n\n\n\nこのようにベクトルで与えてあげるとうまくくっつきました。\n\nこのベクトルで与えてあげる方法は、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest1 <- tribble(\n  ~idA, ~idB, ~value1,\n  1   , 1   , 10     ,\n  1   , 2   , 11     ,\n  2   , 1   , 12     ,\n  2   , 2   , 13     ,\n  1   , 2   , 14     ,\n  2   , 2   , 15    \n  \n)\n\ntest2 <- tribble(\n  ~category, ~id, ~value2,\n  1        , 1  , \"dog\" ,\n  1        , 2  , \"cat\" ,\n  2        , 1  , \"pig\" ,\n  2        , 2  , \"cow\"\n)\n\ntest2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 3\n  category    id value2\n     <dbl> <dbl> <chr> \n1        1     1 dog   \n2        1     2 cat   \n3        2     1 pig   \n4        2     2 cow   \n```\n:::\n:::\n\n\n\n二つ以上の列を基準として結合する場合にも使えて、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest1 %>% \n  left_join(test2, by=c(\"idA\"=\"category\", \"idB\"=\"id\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 4\n    idA   idB value1 value2\n  <dbl> <dbl>  <dbl> <chr> \n1     1     1     10 dog   \n2     1     2     11 cat   \n3     2     1     12 pig   \n4     2     2     13 cow   \n5     1     2     14 cat   \n6     2     2     15 cow   \n```\n:::\n:::\n\n\n\nこんな風にくっつきます。\n\nまた、ここで、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamename1 <- test1 %>% rename(value = value1)\nsamename2 <- test2 %>% rename(value = value2)\n\ncolnames(samename1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"idA\"   \"idB\"   \"value\"\n```\n:::\n\n```{.r .cell-code}\ncolnames(samename2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"category\" \"id\"       \"value\"   \n```\n:::\n:::\n\n\n\nで、同じ名前の列が結合した後に出現する場合もみておきましょう。\n\nbyの中身はここではあまり関係ないので、変数に収納しておきます。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\njoin_this <- c(\"idA\"=\"category\", \"idB\"=\"id\")\n\nsamename1 %>% \n  left_join(samename2, by=join_this)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 4\n    idA   idB value.x value.y\n  <dbl> <dbl>   <dbl> <chr>  \n1     1     1      10 dog    \n2     1     2      11 cat    \n3     2     1      12 pig    \n4     2     2      13 cow    \n5     1     2      14 cat    \n6     2     2      15 cow    \n```\n:::\n:::\n\n\n\nどうでしょうか?\n\n左と右の表にそれぞれ、結合に用いない列名が同じ、valueというものがあるため、left_joinすると、自動的に、value.x value.yと名前が変わっています。この動作、コントロールすることも可能で、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamename1 %>% \n  left_join(samename2, \n            by=join_this, \n            suffix=c(\"__left\",\"__right\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 4\n    idA   idB value__left value__right\n  <dbl> <dbl>       <dbl> <chr>       \n1     1     1          10 dog         \n2     1     2          11 cat         \n3     2     1          12 pig         \n4     2     2          13 cow         \n5     1     2          14 cat         \n6     2     2          15 cow         \n```\n:::\n:::\n\n\n\nと、このようにsuffixアーギュメントに左、右の順番で、列名の後ろにくっつけたい文字列を指定してあげることができます。\n\n",
    "supporting": [
      "s05-069_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}