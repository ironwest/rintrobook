{
  "hash": "a53889b774fd8ba68ce22877a74257d3",
  "result": {
    "markdown": "---\ntitle: mutate()の実践\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n\n\nそれでは新しい列を作る関数、mutateを実際に利用していきましょう。\n\nいきなり演習です!\n\n1つ前の動画でスライドでご提示した表を作成して、新しい列を足すこと、できますか?\n\n<pre>\nもとの表     できあがった表\n\n|col1|col2|  |col1|col2|new|\n|----|----|  |----|----|---|\n|1   |10  |  |1   |10  |11 |\n|2   |20  |  |2   |20  |22 |\n|3   |30  |  |3   |30  |33 |\n|4   |40  |  |4   |40  |44 |\n|----|----|  |----|----|---|\n\n</pre>\n\nできましたか?\n\nやってみましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nhyou <- tibble(\n  col1=c(1,2,3,4), \n  col2=c(10,20,30,40)\n)\n\nhyou\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n   col1  col2\n  <dbl> <dbl>\n1     1    10\n2     2    20\n3     3    30\n4     4    40\n```\n:::\n\n```{.r .cell-code}\nhyou %>% mutate(new = col1 + col2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n   col1  col2   new\n  <dbl> <dbl> <dbl>\n1     1    10    11\n2     2    20    22\n3     3    30    33\n4     4    40    44\n```\n:::\n:::\n\n\n\nできましたね?\n\n予測変換にもちゃんと列名がでてきていましたね?\n\nこのように列を作るのはmutate関数で簡単にできます。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhyou\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n   col1  col2\n  <dbl> <dbl>\n1     1    10\n2     2    20\n3     3    30\n4     4    40\n```\n:::\n:::\n\n\n\nただし、忘れてはいけないのが、mutate関数は「列を作る」機能しかないので、代入してあげないとこのように折角作成した列が反映されていません。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhyou <- hyou %>% mutate(new = col1 + col2)\nhyou\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n   col1  col2   new\n  <dbl> <dbl> <dbl>\n1     1    10    11\n2     2    20    22\n3     3    30    33\n4     4    40    44\n```\n:::\n:::\n\n\n\nmutateの動作を色々と確認しておきましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhyou %>% \n  mutate(test = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n   col1  col2   new  test\n  <dbl> <dbl> <dbl> <dbl>\n1     1    10    11     1\n2     2    20    22     1\n3     3    30    33     1\n4     4    40    44     1\n```\n:::\n:::\n\n\n\nこのように、長さが1のベクトルを入れると、自動的に複製されて、列ができあがります。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhyou %>% \n  mutate(test = c(1,2))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `mutate()`:\nℹ In argument: `test = c(1, 2)`.\nCaused by error:\n! `test` must be size 4 or 1, not 2.\n```\n:::\n:::\n\n\n\nただし、ベクトルの長さが表の行の長さと一致しない場合は、このようにエラーが生じるので、長さがぴったり　か、　1　である必要があります。\n\nまた、mutateは1列だけでなく、同時に複数の列をつくることも可能です。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhyou %>% \n  mutate(\n    n1 = col1 + col2,\n    n2 = col1 - col2,\n    n3 = col1 * col2\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 6\n   col1  col2   new    n1    n2    n3\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1     1    10    11    11    -9    10\n2     2    20    22    22   -18    40\n3     3    30    33    33   -27    90\n4     4    40    44    44   -36   160\n```\n:::\n:::\n\n\n\n他にも、複数列を作成するときに、同じmutateの中で新たに「先に作成した列」を呼び出すことも可能です\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhyou %>% \n  mutate(\n    n4 = col1 + col2,\n    n5 = n4 * col2\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n   col1  col2   new    n4    n5\n  <dbl> <dbl> <dbl> <dbl> <dbl>\n1     1    10    11    11   110\n2     2    20    22    22   440\n3     3    30    33    33   990\n4     4    40    44    44  1760\n```\n:::\n:::\n\n\n\nこれは、後に作成したものは呼べないので注意が必要です\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhyou %>% \n  mutate(\n    n5 = n4 *col2,\n    n4 = col1 + col2\n  )\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `mutate()`:\nℹ In argument: `n5 = n4 * col2`.\nCaused by error:\n! object 'n4' not found\n```\n:::\n:::\n\n\n\n以上、mutate関数の使い方の説明でした。このmutate関数、多分パイプに次いで多用する関数になるとおもいますので、是非、しっかりと動作を抑えておいてください。次の動画では練習問題とその解答です。\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}