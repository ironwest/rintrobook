{
  "hash": "45d63bb137dbe21e7b94424f16ba8042",
  "result": {
    "markdown": "---\ntitle: 実践 pivot_longerで複数列を同時に作成する\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\nここからは、pivot_longerの話です。1つ前の動画で作成したデータですが、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- tibble(\n  age = c(\"<20\",\"20-30\",\"30-40\",\">40\",\"<20\",\"20-30\",\"30-40\",\">40\"),\n  grp = c(\"A\",\"B\",\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"),\n  sex = c(\"m\",\"m\",\"m\",\"m\",\"f\",\"f\",\"f\",\"f\"),\n  val = c(1:8)\n)\n\nyoko <- dat %>% \n  pivot_wider(\n    id_cols = grp,\n    names_from = c(age, sex),\n    values_from = val,\n    values_fill = 0\n  )\n\nyoko\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 9\n  grp   `<20_m` `20-30_m` `30-40_m` `>40_m` `<20_f` `20-30_f` `30-40_f` `>40_f`\n  <chr>   <int>     <int>     <int>   <int>   <int>     <int>     <int>   <int>\n1 A           1         0         3       0       5         0         7       0\n2 B           0         2         0       4       0         6         0       8\n```\n:::\n:::\n\n\n\nこのデータを縦方向に並べてみましょう解説した方法だけだと、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntate1 <- yoko %>% \n  pivot_longer(\n    cols = !grp,\n    names_to = \"name\",\n    values_to = \"value\"\n  )\n\ntate1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 × 3\n   grp   name    value\n   <chr> <chr>   <int>\n 1 A     <20_m       1\n 2 A     20-30_m     0\n 3 A     30-40_m     3\n 4 A     >40_m       0\n 5 A     <20_f       5\n 6 A     20-30_f     0\n 7 A     30-40_f     7\n 8 A     >40_f       0\n 9 B     <20_m       0\n10 B     20-30_m     2\n11 B     30-40_m     0\n12 B     >40_m       4\n13 B     <20_f       0\n14 B     20-30_f     6\n15 B     30-40_f     0\n16 B     >40_f       8\n```\n:::\n:::\n\n\n\nこんな形になるので、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntate1 %>% \n  separate(name,c(\"age\",\"sex\"), sep=\"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 × 4\n   grp   age   sex   value\n   <chr> <chr> <chr> <int>\n 1 A     <20   m         1\n 2 A     20-30 m         0\n 3 A     30-40 m         3\n 4 A     >40   m         0\n 5 A     <20   f         5\n 6 A     20-30 f         0\n 7 A     30-40 f         7\n 8 A     >40   f         0\n 9 B     <20   m         0\n10 B     20-30 m         2\n11 B     30-40 m         0\n12 B     >40   m         4\n13 B     <20   f         0\n14 B     20-30 f         6\n15 B     30-40 f         0\n16 B     >40   f         8\n```\n:::\n:::\n\n\n\nseparate関数や、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntate1 %>% \n  extract(name,c(\"age\",\"sex\"), regex=\"(.+)_(.+)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 × 4\n   grp   age   sex   value\n   <chr> <chr> <chr> <int>\n 1 A     <20   m         1\n 2 A     20-30 m         0\n 3 A     30-40 m         3\n 4 A     >40   m         0\n 5 A     <20   f         5\n 6 A     20-30 f         0\n 7 A     30-40 f         7\n 8 A     >40   f         0\n 9 B     <20   m         0\n10 B     20-30 m         2\n11 B     30-40 m         0\n12 B     >40   m         4\n13 B     <20   f         0\n14 B     20-30 f         6\n15 B     30-40 f         0\n16 B     >40   f         8\n```\n:::\n:::\n\n\n\nextract関数を利用してさらに分割してあげる必要があります\n\n実は、pivot_longer関数に列の分割まで含めていっきにやってくれるargumentが備えられており、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyoko %>% \n  pivot_longer(\n    cols = !grp,\n    names_to = c(\"age\",\"sex\"),\n    values_to = \"value\",\n    names_sep = \"_\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 × 4\n   grp   age   sex   value\n   <chr> <chr> <chr> <int>\n 1 A     <20   m         1\n 2 A     20-30 m         0\n 3 A     30-40 m         3\n 4 A     >40   m         0\n 5 A     <20   f         5\n 6 A     20-30 f         0\n 7 A     30-40 f         7\n 8 A     >40   f         0\n 9 B     <20   m         0\n10 B     20-30 m         2\n11 B     30-40 m         0\n12 B     >40   m         4\n13 B     <20   f         0\n14 B     20-30 f         6\n15 B     30-40 f         0\n16 B     >40   f         8\n```\n:::\n:::\n\n\nnames_toに最終的な変数の名前と、names_sepで分割するための正規表現を与えてあげることで、separate関数をnames_to列に実行したような結果を1つの関数で実施可能です。\n\nextract関数と同じ働きも備えられており、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyoko %>% \n  pivot_longer(\n    cols = !grp,\n    names_to = c(\"age\",\"sex\"),\n    values_to = \"value\",\n    names_pattern = \"(.+)_(.+)\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 × 4\n   grp   age   sex   value\n   <chr> <chr> <chr> <int>\n 1 A     <20   m         1\n 2 A     20-30 m         0\n 3 A     30-40 m         3\n 4 A     >40   m         0\n 5 A     <20   f         5\n 6 A     20-30 f         0\n 7 A     30-40 f         7\n 8 A     >40   f         0\n 9 B     <20   m         0\n10 B     20-30 m         2\n11 B     30-40 m         0\n12 B     >40   m         4\n13 B     <20   f         0\n14 B     20-30 f         6\n15 B     30-40 f         0\n16 B     >40   f         8\n```\n:::\n:::\n\n\n\nnames_toに目的とする最終的な列名、names_patternにextract関数でいうところのregrexを与えてあげると分割することができました。\n\nこの機能、複雑な列名がついた横持ちデータには非常に有効ですので、覚えておいてください(もちろん、pivot_longerとextract等を組み合わせるような使い方でも問題ありません！)\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}