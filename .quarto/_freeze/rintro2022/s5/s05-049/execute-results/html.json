{
  "hash": "9b99c7209520193cff5fecdb2e06f8e7",
  "result": {
    "markdown": "---\ntitle: 練習問題 解答\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n\n\n\nまず、データを取り込みましょう\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(readxl)\ndat <- read_excel(\"data/ifelse_casewhen.xlsx\")\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 19 × 5\n   height weight             bp     alcohol smoking\n    <dbl> <chr>              <chr>    <dbl>   <dbl>\n 1   176. 73.099999999999994 125/78       0       0\n 2   180  78                 107/54       0       0\n 3   150. S6.7               126/81       0       1\n 4   156. 66.2               110/68       0       1\n 5   180. 61.6               110/66       0       0\n 6   174. 64.7               107/83       1       0\n 7   169. 64.400000000000006 113/71       1       0\n 8   172. 86.l               126/72       0       0\n 9   165. 69.7               137/85       1       0\n10   168. 66.900000000000006 110/71       1       0\n11   180. 88.8               109/65       0       0\n12   184  61.6               153/87       1       1\n13   179. 51.4               112/77       0       1\n14   173. 69.2               119/81       0       0\n15   154. 64.5               113/82       1       1\n16   165. 87.1               125/76       1       1\n17   159. 86.3               131/80       1       0\n18   169. 61.1               121/75       0       0\n19   164. 63.O               132/81       0       0\n```\n:::\n:::\n\n\n\n課題1:\n\n身長と体重を利用して、BMIを計算してその結果をbmiという名前の列に保存してください。\n\nまず、datのweight列が文字列型になっているので数字に変換してみましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_weight <- dat %>% \n  select(weight) %>% \n  mutate(num_weight = as.numeric(weight))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `num_weight = as.numeric(weight)`.\nCaused by warning:\n! NAs introduced by coercion\n```\n:::\n\n```{.r .cell-code}\nView(dat_weight)\n```\n:::\n\n\n\nところどころ、欠損しています。\n\nとりあえず、欠損している列のみを抜き出して眺めてみましょう。\n\n欠損の有無は、is.na()関数というものを用います。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_weight %>% \n  filter(is.na(num_weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  weight num_weight\n  <chr>       <dbl>\n1 S6.7           NA\n2 86.l           NA\n3 63.O           NA\n```\n:::\n:::\n\n\n\nはい。ここは、意図的に入力ミスをいれています。\n\n5でなくてS\n1でなくてl\n0でなくてOが使われています。\n\n他のデータはすべて数字にNAになることなく変換できているので、とりあえず、上の3つを置き換えてから数値に変換しましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 <- dat %>% \n  mutate(\n    replace_weight = str_replace_all(weight, \n                                 c(\"S\"=\"5\",\n                                   \"l\"=\"1\",\n                                   \"O\"=\"0\"))\n  ) %>% \n  mutate(num_weight = as.numeric(replace_weight))\n\nView(dat1)\n```\n:::\n\n\n\nこれで、無事、weight列が数字に変換されました。BMIを計算しましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat1 <- dat1 %>% \n  mutate(bmi = num_weight/(height/100)^2)\n\ndat1$bmi\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 23.49201 24.07407 25.09950 27.06353 18.97017 21.29656 22.46839 29.06976\n [9] 25.57047 23.59076 27.28600 18.19471 15.98831 23.09468 27.09118 32.07035\n[17] 34.09341 21.36751 23.39502\n```\n:::\n\n```{.r .cell-code}\nsummary(dat1$bmi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  15.99   21.92   23.59   24.38   27.08   34.09 \n```\n:::\n:::\n\n\n\n課題2:\n\nbmi列の値を利用して、if_else関数を使って、BMIが25以上であれば1、25未満であれば0となる列、obese、を作成してください。\n\nここでif_else関数の動作を確認しておきます。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 <- dat1 %>% \n  mutate(obese = if_else(bmi >= 25, 1, 0))\n```\n:::\n\n\n\nここで作成した変数の分布を確認するためにはsummaryでもよいのですが、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2$obese %>% summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.0000  0.0000  0.0000  0.4211  1.0000  1.0000 \n```\n:::\n:::\n\n\n\n数値型の場合は平均値等がでてきてしまい、個数がわかりません。個数を確認したい場合は、dplyr::count関数という便利な関数があります。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 %>% count(obese)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  obese     n\n  <dbl> <int>\n1     0    11\n2     1     8\n```\n:::\n:::\n\n\n\nあるいは、base::tableも使いやすいです。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2$obese %>% table()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n.\n 0  1 \n11  8 \n```\n:::\n:::\n\n\ncountは、パイプの中で変数名だけ書くような使い方ができますが、tableはベクトルを与えないといけないので注意が必要です\n\n課題3:\n\n血圧の表示が\"120/80\"のように入力されています。これを、sbpとdbpの二つの変数に分割してください。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2$bp[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"125/78\" \"107/54\" \"126/81\" \"110/68\" \"110/66\" \"107/83\" \"113/71\" \"126/72\"\n [9] \"137/85\" \"110/71\"\n```\n:::\n:::\n\n\n\nこのデータを分割するために、正規表現を利用してsbpとdbpを抜き出してみましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat3 <- dat2 %>% \n  mutate(\n    sbp = str_extract(bp,\"^\\\\d+(?=/)\"),\n    dbp = str_extract(bp,\"(?<=/)\\\\d+$\")\n  )\n\ndat3 %>% select(ends_with(\"bp\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 19 × 3\n   bp     sbp   dbp  \n   <chr>  <chr> <chr>\n 1 125/78 125   78   \n 2 107/54 107   54   \n 3 126/81 126   81   \n 4 110/68 110   68   \n 5 110/66 110   66   \n 6 107/83 107   83   \n 7 113/71 113   71   \n 8 126/72 126   72   \n 9 137/85 137   85   \n10 110/71 110   71   \n11 109/65 109   65   \n12 153/87 153   87   \n13 112/77 112   77   \n14 119/81 119   81   \n15 113/82 113   82   \n16 125/76 125   76   \n17 131/80 131   80   \n18 121/75 121   75   \n19 132/81 132   81   \n```\n:::\n:::\n\n\n\n抜き出せましたね。文字列型になっているので数値型に戻しておきましょう\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat3 <- dat3 %>% \n  mutate(\n    sbp = as.numeric(sbp),\n    dbp = as.numeric(dbp)\n  )\n```\n:::\n\n\n\n課題4:\n\n課題3で作成した変数、sbp、dbpを利用して、\n\nsbpが120未満かつdbpが80未満であれば「至適血圧」\nsbpが130未満かつ/あるいはdbp85未満であれば「正常血圧」\nsbpが140未満かつ/あるいはdbp90未満であれば「正常高値血圧」\nsbpが160未満かつ/あるいはdbp100未満であれば「1度高血圧」\nsbpが180未満かつ/あるいはdbp110未満であれば「2度高血圧」\nsbpが180以上かつ/あるいはdbp110以上であれば「3度高血圧」\n\nとした因子型の列を作成してください。\n\nここではcase_whenを利用しましょう。だいぶ複雑です。かつ/あるいはを条件設定するのがややこしいので、収縮期、拡張期それぞれで判定してより重い方を採用する形にしました。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat4 <- dat3 %>% \n  mutate(sbp_kubun = case_when(\n    sbp <  120  ~ 1,\n    sbp <  130  ~ 2,\n    sbp <  140  ~ 3,\n    sbp <  160  ~ 4,\n    sbp <  180  ~ 5,\n    sbp >= 180  ~ 6\n  )) %>% \n  mutate(dbp_kubun = case_when(\n    dbp <  80 ~ 1,\n    dbp <  85 ~ 2,\n    dbp <  90 ~ 3,\n    dbp < 100 ~ 4,\n    dbp < 110 ~ 5,\n    dbp >=110 ~ 6\n  ))\n```\n:::\n\n\n\ncount関数は2変数でも使えます。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat4 %>% \n  count(sbp_kubun, dbp_kubun)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 3\n  sbp_kubun dbp_kubun     n\n      <dbl>     <dbl> <int>\n1         1         1     7\n2         1         2     3\n3         2         1     4\n4         2         2     1\n5         3         2     2\n6         3         3     1\n7         4         3     1\n```\n:::\n:::\n\n\n\nこのsbp_kubunとdbp_kubunの値で大きいほうを採用すれば良いので、if_elseを利用しましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat4 <- dat4 %>% \n  mutate(bp_kubun = if_else(\n    sbp_kubun >= dbp_kubun, sbp_kubun, dbp_kubun\n  ))\n\ndat4 %>% \n  count(bp_kubun, sbp_kubun, dbp_kubun)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 4\n  bp_kubun sbp_kubun dbp_kubun     n\n     <dbl>     <dbl>     <dbl> <int>\n1        1         1         1     7\n2        2         1         2     3\n3        2         2         1     4\n4        2         2         2     1\n5        3         3         2     2\n6        3         3         3     1\n7        4         4         3     1\n```\n:::\n:::\n\n\n\nきちんと狙った通りに分けられていますね?あとは、数値を因子型のラベルをあててあげれば完成です。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbplabel <- c(\"至適\",\"正常\",\"正常高値\",\"1度\",\"2度\",\"3度\")\n\ndat4 <- dat4 %>% \n mutate(bp_kubun = factor(bp_kubun, levels = 1:6, labels=bplabel))\n\ndat4 %>% count(bp_kubun)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  bp_kubun     n\n  <fct>    <int>\n1 至適         7\n2 正常         8\n3 正常高値     3\n4 1度          1\n```\n:::\n\n```{.r .cell-code}\nView(dat4)\n```\n:::\n\n\n\nできあがりです。\n\n課題5：\n\n課題1から課題4までで作成した変数を利用して、高血圧、肥満、飲酒、喫煙のリスクの個数を計算したriskという名前の列を作成してください。\n\n(尚、ここでは、高血圧を1度から3度高血圧、肥満はBMI25以上とします)\n\n血圧のカテゴリーが、0か1になっていないためこれを変換しておきましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat4 %>% \n  count(bp_kubun)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  bp_kubun     n\n  <fct>    <int>\n1 至適         7\n2 正常         8\n3 正常高値     3\n4 1度          1\n```\n:::\n\n```{.r .cell-code}\ndat5 <- dat4 %>% \n  mutate(risk_bp = if_else(as.numeric(bp_kubun) >= 4, 1, 0))\n\ndat5 %>% count(risk_bp, bp_kubun)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  risk_bp bp_kubun     n\n    <dbl> <fct>    <int>\n1       0 至適         7\n2       0 正常         8\n3       0 正常高値     3\n4       1 1度          1\n```\n:::\n:::\n\n\n\nちゃんと0と1で分けられていますね?後は、リスクの個数を足し合わせるだけです。一応、データを確認しておくと、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat5 %>% \n  count(obese, risk_bp, alcohol, smoking)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 × 5\n  obese risk_bp alcohol smoking     n\n  <dbl>   <dbl>   <dbl>   <dbl> <int>\n1     0       0       0       0     6\n2     0       0       0       1     1\n3     0       0       1       0     3\n4     0       1       1       1     1\n5     1       0       0       0     2\n6     1       0       0       1     2\n7     1       0       1       0     2\n8     1       0       1       1     2\n```\n:::\n:::\n\n\n\nです。\n\nrisk列の作成は簡単ですね?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat5 <- dat5 %>% \n  mutate(risk = obese + risk_bp + alcohol + smoking)\n\ndat5 %>% count(risk)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n   risk     n\n  <dbl> <int>\n1     0     6\n2     1     6\n3     2     4\n4     3     3\n```\n:::\n:::\n\n\n\n以上です!\n\nどうでしょうか？\n相当ややこしく感じられたかもしれませんが、ここまで学んでいただいた関数のみで、ここまでデータの加工ができます。\n\n次以降はこれらのデータの加工をより便利にしてくれる関数群を解説していきます。\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}