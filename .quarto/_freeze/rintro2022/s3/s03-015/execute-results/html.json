{
  "hash": "af1547c6f8d3f66d9445a9ad9c2affaa",
  "result": {
    "markdown": "---\ntitle: tibble形式について(L50)\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n\n\n\n\nセクション2では、Rの中に保存されている表形式のデータはdata.frameという形式であると説明しました。\n \n例えば、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- data.frame(a = 1:5, b = c(\"1\",\"2\",\"3\",\"4\",\"5\"))\n\ndf1\n```\n:::\n\n\n\nこんな感じです。\n\nこのdata.frame、実はいくつかデメリットがあって、表の行が長いと、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2 <- data.frame(a = 1:100, b= 1:100)\n\ndf2\n```\n:::\n\n\n\nこんな感じで全部表示してしまうため、\n画面に収まってくれません。\n\nまた、表の列が長いと、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3 <- data.frame(a_long_name=1:10,b_long_name=1:10,\n                  c_long_name=1:10,d_long_name=1:10,\n                  e_long_name=1:10,f_long_name=1:10,\n                  g_long_name=1:10,h_long_name=1:10,\n                  i_long_name=1:10,j_long_name=1:10,\n                  k_long_name=1:10,l_long_name=1:10)\n\ndf3\n```\n:::\n\n\n\nやはり全部表示しようとするためおさまりが悪いですし、\nそれなり大きなデータの分析をしている場合に、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf4 <- data.frame(a_long_name=1:1000,b_long_name=1:1000,\n                  c_long_name=1:1000,d_long_name=1:1000,\n                  e_long_name=1:1000,f_long_name=1:1000,\n                  g_long_name=1:1000,h_long_name=1:1000,\n                  i_long_name=1:1000,j_long_name=1:1000,\n                  k_long_name=1:1000,l_long_name=1:1000,\n                  long_name_1=1:1000,long_name_2=1:1000,\n                  long_name_3=1:1000,long_name_4=1:1000,\n                  long_name_5=1:1000,long_name_6=1:1000,\n                  long_name_7=1:1000,long_name_8=1:1000,\n                  long_name_9=1:1000,long_name_10=1:1000,\n                  long_name_11=1:1000,long_name_12=1:1000)\n\ndf4\n```\n:::\n\n\n\n一回呼び出すと、まあまあ面倒なことになりますとくに、直前の結果を見たいときに、大きなdata.frameを呼び出してしまうと相当上にスクロールしないといけないので面倒です。\n\n今ご説明したデメリットをすべて解決した、data.frame形式をより便利にした形式というのが実はあって、\n\nそれが、\n\ntibble形式\n\nと呼ばれているものです。tibble形式で表を作るには、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?tibble::tibble\n```\n:::\n\n\n\nを使います。\n\ntibbleパッケージも、tidyverseパッケージ群に含まれますので、実際の分析時には単純にtibbleとするだけで呼び出しが可能です。\n\n実際に先ほどのdf1からdf4までをtibbleを使って書いてみると\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntib1 <- tibble(a = 1:5, b = c(\"1\",\"2\",\"3\",\"4\",\"5\"))\ntib2 <- tibble(a = 1:100, b= 1:100)\ntib3 <- tibble(a_long_name=1:10,b_long_name=1:10,\n               c_long_name=1:10,d_long_name=1:10,\n               e_long_name=1:10,f_long_name=1:10,\n               g_long_name=1:10,h_long_name=1:10,\n               i_long_name=1:10,j_long_name=1:10,\n               k_long_name=1:10,l_long_name=1:10)\ntib4 <- tibble(a_long_name=1:1000,b_long_name=1:1000,\n               c_long_name=1:1000,d_long_name=1:1000,\n               e_long_name=1:1000,f_long_name=1:1000,\n               g_long_name=1:1000,h_long_name=1:1000,\n               i_long_name=1:1000,j_long_name=1:1000,\n               k_long_name=1:1000,l_long_name=1:1000,\n               long_name_1=1:1000,long_name_2=1:1000,\n               long_name_3=1:1000,long_name_4=1:1000,\n               long_name_5=1:1000,long_name_6=1:1000,\n               long_name_7=1:1000,long_name_8=1:1000,\n               long_name_9=1:1000,long_name_10=1:1000,\n               long_name_11=1:1000,long_name_12=1:1000)\n```\n:::\n\n\n\ndata.frameを作成する場合とまったく同じ書き方ができて\n\nかつ、コンソール画面の印字は、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1\ntib1\n```\n:::\n\n\n\nこんな感じでdata.frameはただ内容が印字されるだけでしたが、tibbleだと、列名の下に、<int> <chr>等、「型」も記載してくれています。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2\ntib2\n```\n:::\n\n\n\n行方向に長くても、tibbleは適度な長さに\n加工してくれて表示してくれますし\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3\ntib3\n```\n:::\n\n\n\n列方向に長いデータも、コンソール画面でdata.frameのように折り返して表示することはなく、収まらない場合はコラム名 <int>という表記でどんな名前の列があるかを教えてくれます\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(\"この表示を後から見たい\")\ndf4\n\nprint(\"この表示を後から見たい\")\ntib4\n```\n:::\n\n\n\n大きな表を表示したときに、その違いは顕著ですね？\n\ndata.frame/tibbleの前に、あとから見たい結果が印字されていたときに、tibbleの方がはるかに確認しやすいです。\n\n他にも、tibbleはデータ分析を行う上でdata.frameの弱点とされてきたものを多数克服しています。\n\nreadrパッケージにある関数でデータを読み込んだ場合、基本的にはtibble形式でRにとりこまれるためそういう意味でも、readrにある関数を利用してインポートを行うことをお勧めします。\n\n次の動画では、データがtibble形式かを確認する方法と、そうでなかった場合の変換方法について解説しておきます。飛ばしていただいても結構です\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}