{
  "hash": "ba643d14c9542f7d51e93c1877cec55f",
  "result": {
    "markdown": "---\ntitle: 関数(ヘルプファイルの読み方2)(L34)\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n\n\n実際に、実行してみましょう\n\nA Pass a vector to sum, and it will add the elements together.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\n\nB Pass several numbers to sum, and it also adds the elements.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1, 2, 3, 4, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\n\nC In fact, you can pass vectors into several arguments, and everything gets added.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1:2, 3:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\n\nD If there are missing values, the sum is unknown, i.e., also missing, ....\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1:5, NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n\nE ... unless  we exclude missing values explicitly:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1:5, NA, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\n\nここでA-Eは解説のために私がふったアルファベットです。\n\n\nまず、Aですが、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\n\nという記載は、１から5までの数字ベクトルを表します。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1,2,3,4,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\n\nとまったく同じものです。\nなので\n\n`sum(1:5) #A`\n`sum(1,2,3,4,5) #B`\n\nは同じ結果になります。\n\nここで、\n```\n\nUsage: sum(..., na.rm = FALSE)\n\nArguments:\n　# ...\t :  numeric or complex or logical vectors.\n```\n\nとある、...の部分が、1個以上のargumentを意味していることが\nわかります。...と記載があれば、そこには複数のArgumentをいれてよい\nという意味になりますので、覚えておいてください。\n\n尚、sum関数の場合には、...にいれることができるものは\n* numeric\n* complex\n* logical\nなベクトルとありますが、とりあえず、ここではnumericだけを考えます。\n　\n説明には、vectorを入れることができると書いてあるので、vectorそのものを与えてみましょう\n```\n\nsum(1:5) #A\nsum(1,2,3,4,5) #B\n```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum( c(1,2,3,4,5) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n\n```{.r .cell-code}\na <- c(1,2,3,4,5)\nsum(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\n\nすべて同じですね。\n例Cが示しているものは、\n`sum(1:2, 3:5)　#C`　なので、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(c(1,2),c(3,4,5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n\n```{.r .cell-code}\nv1 <- c(1,2)\nv2 <- c(3,4,5)\nsum(v1,v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\n\nという風に二つのベクトルの総和をもとめることも可能です。\n\n\n例Dでは、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1,2,3,4,5,NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n\nとベクトルの中に欠損値が含まれている場合NAが返ってくることが示されています。\n\nその場合例Eのように、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1,2,3,4,5,NA, na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\n\n`na.rm` argumentに対してTRUEという値を与えてあげることで欠損値であるNAを無視して和を返すことができるようになります。\n\nTRUEはLogical型(あるいはBoolean型)と呼ばれるもので、また別の動画で解説しますが、\n\nここでは、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nFALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n\nのどちらかの値をとるもので真か偽かを表すものという理解で結構です。\n\nこの`na.rm` Argument、\n```\n\nUsage: sum(..., na.rm = FALSE)\nArguments:\n　na.rm:\tlogical. Should missing values (including NaN) be removed?\n```\n\nUsageのところで、na.rm=FALSEと初期値が与えられています。\n\n例、A,B,C,Dでna.rmを与えていなくても関数が動いていましたが、このように、Usageのところで初期値が与えられていないargumentがあった場合は、必ず、ご自身の手で入力が必要になりますので注意が必要です。\n\n長い解説にお付き合いください、ありがとうございました。1回の説明では、なかなか全部は理解できないかもしれませんが、ヘルプファイルを呼び出して、Usage、Arguments、Examplesの３つを確認することを知っていると、初めて見る関数を使えるようになるスピードがあがると思いますので、是非、癖付けしてみてください。\n\nそれでは、次の動画では、sum以外の関数をつかって他にもいろいろなことができることを紹介しておきます。\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}