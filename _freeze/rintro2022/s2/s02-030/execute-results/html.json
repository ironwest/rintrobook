{
  "hash": "7e896deb421ea8bc1d4be96905a1c9de",
  "result": {
    "markdown": "---\ntitle: 関数(実際に使ってみよう)(L35)\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n\n\nここまで解説してきた関数を少し復習しておきましょう\n\n|                | 関数               |\n|----------------|--------------------|\n| 型の変換       | as.numeric()       |\n|                | as.character()     |\n| ベクトル       | c()                |\n| データフレーム | data.frame()       |\n|                | View()             |\n| パッケージ     | install.packages() |\n|                | library()          |\n| 関数           | sum()              |\n\n8個もすでに解説していますね。\n\n今回、使う関数は、sum(), summary(), unique(),sort()です。 新しい関数、summaryとuniqueとsort、一度動画をとめて、 ご自身の手でどんな動作をするかをヘルプファイルを みて確認してみてください。\n\nできましたか？\n\n```r\n?summary\n```\n\nのヘルプファイルを呼び出してExamplesの内容を確認してみましょう\n\nExamples\n\nここで\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(attenu)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  event mag station dist accel\n1     1 7.0     117   12 0.359\n2     2 7.4    1083  148 0.014\n3     2 7.4    1095   42 0.196\n4     2 7.4     283   85 0.135\n5     2 7.4     135  107 0.062\n6     2 7.4     475  109 0.054\n```\n:::\n\n```{.r .cell-code}\n#は、Rに最初から組み込まれているデータです。\nsummary(attenu, digits = 4) #-> summary.data.frame(...), default precision\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     event            mag           station         dist       \n Min.   : 1.00   Min.   :5.000   117    :  5   Min.   :  0.50  \n 1st Qu.: 9.00   1st Qu.:5.300   1028   :  4   1st Qu.: 11.32  \n Median :18.00   Median :6.100   113    :  4   Median : 23.40  \n Mean   :14.74   Mean   :6.084   112    :  3   Mean   : 45.60  \n 3rd Qu.:20.00   3rd Qu.:6.600   135    :  3   3rd Qu.: 47.55  \n Max.   :23.00   Max.   :7.700   (Other):147   Max.   :370.00  \n                                 NA's   : 16                   \n     accel        \n Min.   :0.00300  \n 1st Qu.:0.04425  \n Median :0.11300  \n Mean   :0.15422  \n 3rd Qu.:0.21925  \n Max.   :0.81000  \n                  \n```\n:::\n\n```{.r .cell-code}\nsummary(attenu $ station, maxsum = 20) #-> summary.factor(...)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    117    1028     113     112     135     475    1030    1083    1093    1095 \n      5       4       4       3       3       3       2       2       2       2 \n    111     116    1219    1299     130    1308    1377    1383 (Other)    NA's \n      2       2       2       2       2       2       2       2     120      16 \n```\n:::\n\n```{.r .cell-code}\nlst <- unclass(attenu$station) > 20 # logical with NAs\n## summary.default() for logicals -- different from *.factor:\nsummary(lst)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Mode   FALSE    TRUE    NA's \nlogical      28     138      16 \n```\n:::\n\n```{.r .cell-code}\nsummary(as.factor(lst))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFALSE  TRUE  NA's \n   28   138    16 \n```\n:::\n:::\n\n\n\n現時点ではわかりにくいものがいくつかあると思いますが、 コースの中で解説していきますので心配ありません。\n\nとりあえず、Examplesの内容からは、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(attenu)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     event            mag           station         dist       \n Min.   : 1.00   Min.   :5.000   117    :  5   Min.   :  0.50  \n 1st Qu.: 9.00   1st Qu.:5.300   1028   :  4   1st Qu.: 11.32  \n Median :18.00   Median :6.100   113    :  4   Median : 23.40  \n Mean   :14.74   Mean   :6.084   112    :  3   Mean   : 45.60  \n 3rd Qu.:20.00   3rd Qu.:6.600   135    :  3   3rd Qu.: 47.55  \n Max.   :23.00   Max.   :7.700   (Other):147   Max.   :370.00  \n                                 NA's   : 16                   \n     accel        \n Min.   :0.00300  \n 1st Qu.:0.04425  \n Median :0.11300  \n Mean   :0.15422  \n 3rd Qu.:0.21925  \n Max.   :0.81000  \n                  \n```\n:::\n:::\n\n\n\nとすることで、データフレームやベクトルを集計してくれる 関数だということがなんとなくわかると思います。\n\nunique関数もみていきましょう\n\n```r\n?unique\n```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3:5, 11:8, 8 + 0:5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3  4  5 11 10  9  8  8  9 10 11 12 13\n```\n:::\n\n```{.r .cell-code}\n(ux <- unique(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3  4  5 11 10  9  8 12 13\n```\n:::\n\n```{.r .cell-code}\n(u2 <- unique(x, fromLast = TRUE)) # different order\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3  4  5  8  9 10 11 12 13\n```\n:::\n\n```{.r .cell-code}\nstopifnot(identical(sort(ux), sort(u2)))\n\nlength(unique(sample(100, 100, replace = TRUE)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 57\n```\n:::\n\n```{.r .cell-code}\n## approximately 100(1 - 1/e) = 63.21\n\nhead(unique(iris))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n:::\n:::\n\n\n\nunique関数は、ちょっと例がわかりづらいですが、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(1,1,1,1,1,3,3,3,3,3,2,2,2,2,2)\nunique(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 2\n```\n:::\n:::\n\n\n\nこんな感じでベクトルの中から重複をなくして 「ユニーク」な要素をもつベクトルを作ってくれる という関数です。\n\n最後に、\n\n```r\n?sort\n```\n\nこれも、ヘルプファイルが難しいですね。 単純に、入れたベクトルの順番を昇順・降順に並び替えてくれる 関数です。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 1 1 1 3 3 3 3 3 2 2 2 2 2\n```\n:::\n\n```{.r .cell-code}\nunique(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 2\n```\n:::\n\n```{.r .cell-code}\nsort(unique(vec))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\n\nこんな感じで、先ほど作成したvecをユニークにしたもの の順番をソートしてくれます。\n\nヘルプファイルを見ていきましょう\n\n```r\n?sort\n```\n\nUsageのところの一番上の使い方として、 `sort(x, decreasing = FALSE, ...)`とあります。`decreasing`のargumentには初期値が 与えられていて、 `decreasing`の説明をみると、 `logical. Should the sort be increasing or decreasing?`とあります。 logicalなので、TRUEかFALSEをいれられます。 \n\n初期値のFALSEではない値にしてみましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(unique(vec), decreasing=FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nsort(unique(vec), decreasing=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 2 1\n```\n:::\n:::\n\n\n\nと、こんな具合で順番が入れ替わりました。\n\nいかがでしょうか？関数のヘルプファイルをみて、 その関数の使い方を理解することが、なんとなくできそうに 感じていただいていれば、OKです。\n\nそれでは、本セクションのまとめを次の動画でしてから、 次のセクションにすすんでいきましょう。\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}