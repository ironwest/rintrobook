{
  "hash": "6a88f58719daf4c477e3fb64d5558cd7",
  "result": {
    "markdown": "---\ntitle: データの作成\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n\n\nそれではRで集計を行っていきましょう。スライドでお示しした通り、集計とは、ベクトル（数字や文字列、因子などの要素）の特徴を何かしらの代表的な値にまとめることになります\n \nRでこれを実施するためには、やりたい集計に応じた関数を知っておく必要がありますとりあえず、\n \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n-- Attaching core tidyverse packages ------------------------ tidyverse 2.0.0 --\nv dplyr     1.1.2     v readr     2.1.4\nv forcats   1.0.0     v stringr   1.5.0\nv ggplot2   3.4.2     v tibble    3.2.1\nv lubridate 1.9.2     v tidyr     1.3.0\nv purrr     1.0.1     \n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\ni Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\ndat <- tibble(\n  num = c(1  ,2  ,3  ,4  ,5  ,6  ,7  ,8  ,9  ,10),\n  fac2 =c(\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\",\"a\",\"b\") %>% as.factor(),\n  fac3 =c(\"A\",\"B\",\"C\",\"A\",\"B\",\"C\",\"A\",\"B\",\"C\",\"A\") %>% as.factor()\n)\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 3\n     num fac2  fac3 \n   <dbl> <fct> <fct>\n 1     1 a     A    \n 2     2 b     B    \n 3     3 a     C    \n 4     4 b     A    \n 5     5 a     B    \n 6     6 b     C    \n 7     7 a     A    \n 8     8 b     B    \n 9     9 a     C    \n10    10 b     A    \n```\n:::\n:::\n\n\n\nこんな感じのtibbleを集計していくことを考えましょう\n\n* numは数字ベクトル、\n* fac2はレベルが二つの因子ベクトル、\n* fac3はレベルが3つの因子ベクトル\n\nとなります。\n\n\nちなみに、繰り返しを簡単にできるrepという関数を利利すると\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep( c(\"a\",\"b\"), 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"a\" \"b\" \"a\" \"b\" \"a\" \"b\"\n```\n:::\n:::\n\n\n\nという感じで、最初に与えた要素、次に与えた数字の数だけくりかえしたベクトルを返してくれるので、上のdatは、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- tibble(\n  num = 1:10,\n  fac2 = rep(c(\"a\",\"b\"), 5),\n  fac3 = rep(c(\"A\",\"B\",\"C\"), 4)[1:10]\n)\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 3\n     num fac2  fac3 \n   <int> <chr> <chr>\n 1     1 a     A    \n 2     2 b     B    \n 3     3 a     C    \n 4     4 b     A    \n 5     5 a     B    \n 6     6 b     C    \n 7     7 a     A    \n 8     8 b     B    \n 9     9 a     C    \n10    10 b     A    \n```\n:::\n:::\n\n\n\nとも書けます。fac3で[1:10]としているのは\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(num  = 1:3, \n       test = c(\"a\",\"b\",\"c\",\"a\",\"b\",\"c\"))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `tibble()`:\n! Tibble columns must have compatible sizes.\n* Size 3: Existing data.\n* Size 6: Column `test`.\ni Only values of size one are recycled.\n```\n:::\n:::\n\n\n\nこのように、tibble内では、すべて同じ長さの要素を与えないとエラーが生じるので、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(num  = 1:3, \n       test = c(\"a\",\"b\",\"c\",\"a\",\"b\",\"c\")[1:3] )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n    num test \n  <int> <chr>\n1     1 a    \n2     2 b    \n3     3 c    \n```\n:::\n:::\n\n\n\nようそをnumの数と同じだけにするためのものです。repを使うと与えた要素の長さの倍数の長さにしかならないので、この[]は地味に大切です。\n\n100行で同様のパターンのものを作りたければ\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- tibble(\n  num = 1:100,\n  fac2 = rep(c(\"a\",\"b\"), 50),\n  fac3 = rep(c(\"A\",\"B\",\"C\"), 100)[1:100] \n)\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 100 x 3\n     num fac2  fac3 \n   <int> <chr> <chr>\n 1     1 a     A    \n 2     2 b     B    \n 3     3 a     C    \n 4     4 b     A    \n 5     5 a     B    \n 6     6 b     C    \n 7     7 a     A    \n 8     8 b     B    \n 9     9 a     C    \n10    10 b     A    \n# i 90 more rows\n```\n:::\n:::\n\n\n\n(本当はfac3繰り返し回数は34が最適ですが、計算するのが面倒なので全部100としています)\n\nですし、X行のものを作る関数にしたければ、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenXrow <- function(X){\n  tibble(\n    num = 1:X,\n    fac2 = rep(c(\"a\",\"b\")    , X)[1:X],\n    fac3 = rep(c(\"A\",\"B\",\"C\"), X)[1:X]\n  )\n}\n\ndat <- genXrow(11)\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 11 x 3\n     num fac2  fac3 \n   <int> <chr> <chr>\n 1     1 a     A    \n 2     2 b     B    \n 3     3 a     C    \n 4     4 b     A    \n 5     5 a     B    \n 6     6 b     C    \n 7     7 a     A    \n 8     8 b     B    \n 9     9 a     C    \n10    10 b     A    \n11    11 a     B    \n```\n:::\n\n```{.r .cell-code}\ngenXrow(10000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10,000 x 3\n     num fac2  fac3 \n   <int> <chr> <chr>\n 1     1 a     A    \n 2     2 b     B    \n 3     3 a     C    \n 4     4 b     A    \n 5     5 a     B    \n 6     6 b     C    \n 7     7 a     A    \n 8     8 b     B    \n 9     9 a     C    \n10    10 b     A    \n# i 9,990 more rows\n```\n:::\n:::\n\n\n\nとなります\n\n余談でした。\n\nこういう風に、データを自分で作れるようになると色々な関数や統計的なことを勉強する際に自分で仕組みがわかっているデータを作成できるのでおすすめです。\n\nそれでは、次に、集計用の関数の解説をおこなっていきましょう",
    "supporting": [
      "s06-004_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}