{
  "hash": "262a59ed28fb9e63c7bbc36b732f7510",
  "result": {
    "markdown": "---\ntitle: group_by関数の使い方の例\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\nそれでは、group_by関数の使い方について解説していきます。\n\n利用するデータは、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{\n  set.seed(12345)\n  dat <- tibble(\n    q1 = sample(letters[1:3],100,replace = TRUE),\n    q2 = sample(letters[1:3],100,replace = TRUE),\n    q3 = sample(letters[1:3],100,replace = TRUE),\n    q4 = sample(letters[1:3],100,replace = TRUE),\n    q5 = sample(letters[1:3],100,replace = TRUE)\n  )\n  write_excel_csv(dat,\"data/practice_group_by.csv\")  \n}\n\ndat <- read_csv(\"data/practice_group_by.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 100 Columns: 5\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (5): q1, q2, q3, q4, q5\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\n\nこんなデータです。\n\nまず例えば、q1変数での解答はそれぞれ何件あるかを確認するには、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  group_by(q1) %>% \n  summarise(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  q1        n\n  <chr> <int>\n1 a        27\n2 b        35\n3 c        38\n```\n:::\n:::\n\n\n\nとしてあげることで、q1でグループ化してsummariseで数を数えることができました\n\nおなじように、q1とq2の変数の組み合わせが何件あるのかを確認するには、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex2 <- dat %>% \n  group_by(q1,q2) %>% \n  summarise(n = n())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'q1'. You can override using the `.groups`\nargument.\n```\n:::\n\n```{.r .cell-code}\nex2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 x 3\n# Groups:   q1 [3]\n  q1    q2        n\n  <chr> <chr> <int>\n1 a     a         7\n2 a     b        10\n3 a     c        10\n4 b     a         7\n5 b     b        12\n6 b     c        16\n7 c     a        15\n8 c     b        13\n9 c     c        10\n```\n:::\n:::\n\n\n\nこのように、group_byに二つの変数を入れるとOKです。ただ、注意が必要なのは、Summariseをすると、groupの指定が「1段階解除される」という仕組みになっており、ex2データのグループは、q1のみとなっています。\n\nグループが残っていると、おもわぬ動作が生じることがあります\n\n例えば、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex2 %>% select(!q1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nAdding missing grouping variables: `q1`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 x 3\n# Groups:   q1 [3]\n  q1    q2        n\n  <chr> <chr> <int>\n1 a     a         7\n2 a     b        10\n3 a     c        10\n4 b     a         7\n5 b     b        12\n6 b     c        16\n7 c     a        15\n8 c     b        13\n9 c     c        10\n```\n:::\n:::\n\n\n\nと、ex2からq1変数を除去しようとしても、groupに利用されている変数は除去できず、もとにもどってしまいます。なので、グループ集計等、グループである必然性がないデータについては、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex3 <- ex2 %>% ungroup()\n\nex3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 x 3\n  q1    q2        n\n  <chr> <chr> <int>\n1 a     a         7\n2 a     b        10\n3 a     c        10\n4 b     a         7\n5 b     b        12\n6 b     c        16\n7 c     a        15\n8 c     b        13\n9 c     c        10\n```\n:::\n:::\n\n\n\nこのように、ungroup()関数を用いてグループを解除しておくか、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  group_by(q1,q2) %>% \n  summarise(n = n(), .groups=\"drop\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 x 3\n  q1    q2        n\n  <chr> <chr> <int>\n1 a     a         7\n2 a     b        10\n3 a     c        10\n4 b     a         7\n5 b     b        12\n6 b     c        16\n7 c     a        15\n8 c     b        13\n9 c     c        10\n```\n:::\n:::\n\n\n\nこのように.groups=\"drop\"という設定をしておくと、自動的にグループ化が解除された形でデータが帰ってきます。\n\n注意：この.groups=dropという仕様は、この動画を作成時点で実験的な試みらしいので、将来的には動作が変更される可能性があります。\n\nなので、個人的にはungroup()で明示的にグループ解除を必要がなくなったら行う癖付けをしておくほうがよいように思っています。\n\n(1つの関数で色々な処理をするよりも、1関数、1処理でシンプルに書いておく方が分かりやすい気がします。)\n\nさて、ここまでの例では、組み合わせを含めて数を数えるという方法を解説してきました\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nex3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 x 3\n  q1    q2        n\n  <chr> <chr> <int>\n1 a     a         7\n2 a     b        10\n3 a     c        10\n4 b     a         7\n5 b     b        12\n6 b     c        16\n7 c     a        15\n8 c     b        13\n9 c     c        10\n```\n:::\n:::\n\n\n\nただ、実は、この処理をもっと簡単に書く方法がり、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% count(q1,q2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 x 3\n  q1    q2        n\n  <chr> <chr> <int>\n1 a     a         7\n2 a     b        10\n3 a     c        10\n4 b     a         7\n5 b     b        12\n6 b     c        16\n7 c     a        15\n8 c     b        13\n9 c     c        10\n```\n:::\n:::\n\n\n\nこのように、count関数を利用しましよう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?count\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nstarting httpd help server ... done\n```\n:::\n:::\n\n\n\nをみても、ほぼ同じ処理であると書いてありますね。\n\n次にgroup_byとmutateを組み合わせてみましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 <- dat %>% \n  count(q1,q2)\n\ndat2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 x 3\n  q1    q2        n\n  <chr> <chr> <int>\n1 a     a         7\n2 a     b        10\n3 a     c        10\n4 b     a         7\n5 b     b        12\n6 b     c        16\n7 c     a        15\n8 c     b        13\n9 c     c        10\n```\n:::\n:::\n\n\n\nこのように集計されたデータに対して、\n\n例えば、q1=aの中で、q2=aが占める割合等を計算したいときに、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 %>% \n  group_by(q1) %>% \n  mutate(nq1 = sum(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 x 4\n# Groups:   q1 [3]\n  q1    q2        n   nq1\n  <chr> <chr> <int> <int>\n1 a     a         7    27\n2 a     b        10    27\n3 a     c        10    27\n4 b     a         7    35\n5 b     b        12    35\n6 b     c        16    35\n7 c     a        15    38\n8 c     b        13    38\n9 c     c        10    38\n```\n:::\n:::\n\n\n\nこのように書いてあげると、q1という集団毎のsum(n)の値を入れた列を新たに作成することができます。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 %>% \n  #group_by(q1) %>% \n  mutate(nq1 = sum(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 x 4\n  q1    q2        n   nq1\n  <chr> <chr> <int> <int>\n1 a     a         7   100\n2 a     b        10   100\n3 a     c        10   100\n4 b     a         7   100\n5 b     b        12   100\n6 b     c        16   100\n7 c     a        15   100\n8 c     b        13   100\n9 c     c        10   100\n```\n:::\n:::\n\n\n\nこのように,group_byがない場合は、単純にn列の全ての数字を足した値が繰り返してnq1列に挿入されますが、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 %>% \n  group_by(q1) %>% \n  mutate(nq1 = sum(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 x 4\n# Groups:   q1 [3]\n  q1    q2        n   nq1\n  <chr> <chr> <int> <int>\n1 a     a         7    27\n2 a     b        10    27\n3 a     c        10    27\n4 b     a         7    35\n5 b     b        12    35\n6 b     c        16    35\n7 c     a        15    38\n8 c     b        13    38\n9 c     c        10    38\n```\n:::\n:::\n\n\n\nグループ化してあげると、q1のグループ毎に集計された値がnq1に含まれます。ここでも、group_byでデータに線が入って分割された別々の表で処理が行われているとイメージがあると、mutateの動作も理解できるのではないでしょうか?\n\n次の動画からはデータの処理でよく遭遇する「差の計算」について解説していきます\n\n",
    "supporting": [
      "s06-017_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}