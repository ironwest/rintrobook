{
  "hash": "b85eaf64a06a77dffdc2f7ccff397126",
  "result": {
    "markdown": "---\ntitle: :時間の集計4 Rで実施2(sld126)\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(lubridate)\n\nplot_id <- function(.data,tgt_id){\n  gdat <- .data %>% \n    filter(id %in% tgt_id) %>% \n    mutate(row_n = n():1) %>%\n    mutate(points = map2(start,end, ~{.x:.y})) %>% \n    select(id,med,row_n,points) %>% \n    unnest(c(points)) %>% \n    mutate(points = as_date(points))\n  \n  ggplot(gdat) +\n    geom_point(aes(x = points, y = as.factor(row_n), color = med)) +\n    scale_y_discrete(labels=NULL) +\n    facet_wrap(~id, scales = \"free\")\n}\n```\n:::\n\n\n\nここまでの解説では、各IDの薬剤毎ということは加味しておりませんでしたが、ここからはそこも加味して処理を書いていきます。\n\nご自身で試みてみましたか？\n\nこの処理ですが、id列とmed列を含んだ処理を書いてく形ですやってみましょう\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- read_csv(\"data/time.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 400 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (1): med\ndbl  (1): id\ndate (2): start, end\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\ndat2 <- dat %>% \n  arrange(id,med,start) %>% #ここにmed,startを追加  \n  mutate(interv = interval(start, end)) %>%  #同じ\n  group_by(id, med) %>%  #idとmedでグループ化\n  mutate(\n    prev_overlap   = int_overlaps(interv, lag(interv)),\n    prev_edgealign = int_aligns(interv, lag(interv)),\n  ) %>% \n  mutate(prev_oa = prev_overlap | prev_edgealign) #グループ化後は同じ\n\nView(dat2)\n```\n:::\n\n\n\nうまく、重複・期間の端が隣接している行をTRUEとふれていますね？\n\nあとは、NAをFALSEで埋めてあげて、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat3 <- dat2 %>% \n  replace_na(list(prev_oa = FALSE))\n\nView(dat3)\n```\n:::\n\n\n\n各IDの各処方毎、処方期間の重複をふくめて、IDを振ってあげます。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 400 × 8\n# Groups:   id, med [326]\n      id med   start      end        interv                         prev_overlap\n   <dbl> <chr> <date>     <date>     <Interval>                     <lgl>       \n 1     1 A     2020-04-14 2020-05-07 2020-04-14 UTC--2020-05-07 UTC NA          \n 2     1 B     2020-04-01 2020-04-09 2020-04-01 UTC--2020-04-09 UTC NA          \n 3     2 A     2020-05-12 2020-06-30 2020-05-12 UTC--2020-06-30 UTC NA          \n 4     2 A     2020-05-24 2020-06-17 2020-05-24 UTC--2020-06-17 UTC TRUE        \n 5     3 A     2020-05-31 2020-08-01 2020-05-31 UTC--2020-08-01 UTC NA          \n 6     4 B     2020-04-03 2020-06-04 2020-04-03 UTC--2020-06-04 UTC NA          \n 7     5 A     2020-04-26 2020-07-09 2020-04-26 UTC--2020-07-09 UTC NA          \n 8     5 B     2020-04-15 2020-05-10 2020-04-15 UTC--2020-05-10 UTC NA          \n 9     5 B     2020-04-15 2020-04-28 2020-04-15 UTC--2020-04-28 UTC TRUE        \n10     6 A     2020-05-16 2020-06-14 2020-05-16 UTC--2020-06-14 UTC NA          \n# ℹ 390 more rows\n# ℹ 2 more variables: prev_edgealign <lgl>, prev_oa <lgl>\n```\n:::\n:::\n\n\n\nにかけたグループはまだそのまま残っているので、単純に、mutateするだけでよくて、ここも、処理内容は変わりません\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat4 <- dat3 %>% \n  mutate(presc_id = cumsum(!prev_oa)) \n\nplot_id(dat, c(39,140))\n```\n\n::: {.cell-output-display}\n![](s06-033_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\ndat4 %>% \n  filter(id %in% c(39,140)) %>% \n  select(id,med,start,end,presc_id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n# Groups:   id, med [2]\n     id med   start      end        presc_id\n  <dbl> <chr> <date>     <date>        <int>\n1    39 C     2020-04-27 2020-05-01        1\n2    39 C     2020-05-08 2020-05-14        2\n3    39 C     2020-05-11 2020-06-04        2\n4   140 B     2020-04-08 2020-04-24        1\n5   140 B     2020-05-01 2020-07-13        2\n6   140 B     2020-05-09 2020-06-01        2\n```\n:::\n:::\n\n\n\nいかがでしょうか?うまく、「重複毎」に、presc_idが振られていますね?\n\n後は、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat5 <- dat4 %>%\n  group_by(id, med, presc_id) %>% #グループを作り直し。id,medを追加\n  summarise(start = min(start), end = max(end)) # 同じ\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'id', 'med'. You can override using the\n`.groups` argument.\n```\n:::\n:::\n\n\n\nうまくいきました。\n\n尚、ここで、ちょっとだけ注意が必要なのが、summarise実行時にでているメッセージです\n\n`summarise()` has grouped output by 'id', 'med'.You can override using the `.groups` argument.\n \nとあるのですが、これは、summarise実行ででてきた結果に「id med」の二つのグループが残っているというメッセージです。\n\n実際、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 346 × 5\n# Groups:   id, med [326]\n      id med   presc_id start      end       \n   <dbl> <chr>    <int> <date>     <date>    \n 1     1 A            1 2020-04-14 2020-05-07\n 2     1 B            1 2020-04-01 2020-04-09\n 3     2 A            1 2020-05-12 2020-06-30\n 4     3 A            1 2020-05-31 2020-08-01\n 5     4 B            1 2020-04-03 2020-06-04\n 6     5 A            1 2020-04-26 2020-07-09\n 7     5 B            1 2020-04-15 2020-05-10\n 8     6 A            1 2020-05-16 2020-06-14\n 9     6 B            1 2020-05-02 2020-05-07\n10     7 C            1 2020-05-28 2020-06-27\n# ℹ 336 more rows\n```\n:::\n:::\n\n\n\nで確認すると確かにグループが残存しています。sumariseでは最後のグループだけが解消されるイメージです。このグループを消したい場合は、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat5 %>% ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 346 × 5\n      id med   presc_id start      end       \n   <dbl> <chr>    <int> <date>     <date>    \n 1     1 A            1 2020-04-14 2020-05-07\n 2     1 B            1 2020-04-01 2020-04-09\n 3     2 A            1 2020-05-12 2020-06-30\n 4     3 A            1 2020-05-31 2020-08-01\n 5     4 B            1 2020-04-03 2020-06-04\n 6     5 A            1 2020-04-26 2020-07-09\n 7     5 B            1 2020-04-15 2020-05-10\n 8     6 A            1 2020-05-16 2020-06-14\n 9     6 B            1 2020-05-02 2020-05-07\n10     7 C            1 2020-05-28 2020-06-27\n# ℹ 336 more rows\n```\n:::\n:::\n\n\n\nとグループを消す処理を意図的に入れてあげるか、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat4 %>%\n  group_by(id, med, presc_id) %>% \n  summarise(start = min(start), end = max(end), .groups = \"drop\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 346 × 5\n      id med   presc_id start      end       \n   <dbl> <chr>    <int> <date>     <date>    \n 1     1 A            1 2020-04-14 2020-05-07\n 2     1 B            1 2020-04-01 2020-04-09\n 3     2 A            1 2020-05-12 2020-06-30\n 4     3 A            1 2020-05-31 2020-08-01\n 5     4 B            1 2020-04-03 2020-06-04\n 6     5 A            1 2020-04-26 2020-07-09\n 7     5 B            1 2020-04-15 2020-05-10\n 8     6 A            1 2020-05-16 2020-06-14\n 9     6 B            1 2020-05-02 2020-05-07\n10     7 C            1 2020-05-28 2020-06-27\n# ℹ 336 more rows\n```\n:::\n:::\n\n\n\nと、summariseの時点で.group引数に\"drop\"を与えるとsummarise時点でgroupが消えます。こちらの方法、本コースを作成している時点では、実験的な機能なので、将来使えなくなる可能性もあるのでその点ご留意ください。このコースでは、ungroupを主に利用します。それで、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_fin <- dat5 %>% \n  ungroup() %>%\n  arrange(id,med,start) #並び替えておきます。\n```\n:::\n\n\n\nこれで完成です。\n\n可視化して確認しておきましょう\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompare_plot <- function(.data1, .data2, tgt_id){\n  pre_graph  <- plot_id(.data1, tgt_id)\n  post_graph <- plot_id(.data2, tgt_id)\n  \n  cowplot::plot_grid(pre_graph, post_graph, nrow=2)\n}\n\ncompare_plot(dat,dat_fin,c(2,5,10))\n```\n\n::: {.cell-output-display}\n![](s06-033_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n上のグラフがもとのもので、下のグラフが処理後のものですうまく期間が一つにID、薬毎にまとまっていますね？\n\nただし、今回の処理、一つ上のものとの比較だけをしているため、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompare_plot(dat,dat_fin,c(39,93,140))\n```\n\n::: {.cell-output-display}\n![](s06-033_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\nid 93番が想定した結果と少し違います。これ、なぜかわかりますか？\n\n少し考えてみてください。次の動画で解説していきます。\n\n",
    "supporting": [
      "s06-033_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}