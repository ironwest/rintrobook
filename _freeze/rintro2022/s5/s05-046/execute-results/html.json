{
  "hash": "a92b2a2d19a2528bfbc8ec5879556c64",
  "result": {
    "markdown": "---\ntitle: 実践 if_else\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\nまずはif_elseの簡単なケースを見ていきましょう。if_else関数はスライドでの説明があった通り、与えたロジカルベクトルに対してTRUEの場合、FALSEの場合にそれぞれ違う要素を返してくれる関数です。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif_else(TRUE, \"trueです\", \"falseです\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"trueです\"\n```\n:::\n\n```{.r .cell-code}\nif_else(FALSE, \"trueです\", \"falseです\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"falseです\"\n```\n:::\n\n```{.r .cell-code}\nif_else(c(T,F,T), \"trueです\",\"falseです\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"trueです\"  \"falseです\" \"trueです\" \n```\n:::\n:::\n\n\n\nこのように、TとFの場合でそれぞれ違う結果が与えた長さだけ返ってきていることがわかりますか?\n\nこれとmutateを組み合わせると、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- tibble(num = 1:10)\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 1\n     num\n   <int>\n 1     1\n 2     2\n 3     3\n 4     4\n 5     5\n 6     6\n 7     7\n 8     8\n 9     9\n10    10\n```\n:::\n\n```{.r .cell-code}\ndat %>% \n  mutate(kekka = num > 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n     num kekka\n   <int> <lgl>\n 1     1 FALSE\n 2     2 FALSE\n 3     3 FALSE\n 4     4 FALSE\n 5     5 TRUE \n 6     6 TRUE \n 7     7 TRUE \n 8     8 TRUE \n 9     9 TRUE \n10    10 TRUE \n```\n:::\n\n```{.r .cell-code}\ndat %>% \n  mutate(kekka = if_else(num > 4, \"4より大きい\",\"4以下\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n     num kekka      \n   <int> <chr>      \n 1     1 4以下      \n 2     2 4以下      \n 3     3 4以下      \n 4     4 4以下      \n 5     5 4より大きい\n 6     6 4より大きい\n 7     7 4より大きい\n 8     8 4より大きい\n 9     9 4より大きい\n10    10 4より大きい\n```\n:::\n:::\n\n\n\nこんな感じである列の状況に応じた、新しい列をつくることが可能です。\n\n条件にはロジカルベクトルであればなんでもよいので、正規表現で学んだような、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- tibble(\n  mixed = c(\"1\",\"l\",\"5\",\"S\",\"O\",\"0\")\n)\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 1\n  mixed\n  <chr>\n1 1    \n2 l    \n3 5    \n4 S    \n5 O    \n6 0    \n```\n:::\n\n```{.r .cell-code}\ndat %>% \n  mutate(\n    is_num = if_else(str_detect(mixed,\"\\\\d+\"),\"NUM\",\"ELSE\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  mixed is_num\n  <chr> <chr> \n1 1     NUM   \n2 l     ELSE  \n3 5     NUM   \n4 S     ELSE  \n5 O     ELSE  \n6 0     NUM   \n```\n:::\n:::\n\n\n\nのような形で数字のみの文字列とそうでない場合で別々の記載をすることが可能です。\n\nここまでの例では、TRUE、FALSEの場合、それぞれ単一の結果を返していますが、ここは入力されるロジカルベクトルと同じ長さのベクトルでもよいです。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- tibble(\n  num = 1:10,\n  alpha = letters[1:10],\n  ALPHA = LETTERS[1:10]\n)\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n     num alpha ALPHA\n   <int> <chr> <chr>\n 1     1 a     A    \n 2     2 b     B    \n 3     3 c     C    \n 4     4 d     D    \n 5     5 e     E    \n 6     6 f     F    \n 7     7 g     G    \n 8     8 h     H    \n 9     9 i     I    \n10    10 j     J    \n```\n:::\n:::\n\n\n\nこんな表があったとして、numが5以上の場合はalpha列の結果を返したくて、numが5未満の場合はALPHAの結果を返したい場合\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% mutate(kekka = if_else(num>=5, alpha, ALPHA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 4\n     num alpha ALPHA kekka\n   <int> <chr> <chr> <chr>\n 1     1 a     A     A    \n 2     2 b     B     B    \n 3     3 c     C     C    \n 4     4 d     D     D    \n 5     5 e     E     e    \n 6     6 f     F     f    \n 7     7 g     G     g    \n 8     8 h     H     h    \n 9     9 i     I     i    \n10    10 j     J     j    \n```\n:::\n:::\n\n\n\nnumの値に応じて、kekka列の値が入力されていますね?\n\nif_else関数を利用していて、生じるエラーで代表的なものが型の不一致です。\n\nベクトルは\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1,2,\"a\",3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"2\" \"a\" \"3\"\n```\n:::\n:::\n\n\n\n複数の型が混在することができないという話覚えていますか？if_else関数は、もし結果のベクトルに複数の型が入っていた場合に、明確にエラーを返します。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- tibble(\n  num = 1:10, \n  cond1 = letters[1:10],\n  cond2 = 1:10\n)\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n     num cond1 cond2\n   <int> <chr> <int>\n 1     1 a         1\n 2     2 b         2\n 3     3 c         3\n 4     4 d         4\n 5     5 e         5\n 6     6 f         6\n 7     7 g         7\n 8     8 h         8\n 9     9 i         9\n10    10 j        10\n```\n:::\n:::\n\n\n\nこういうデータがあるとして、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  mutate(result = if_else(num >= 5, cond1, cond2))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `mutate()`:\nℹ In argument: `result = if_else(num >= 5, cond1, cond2)`.\nCaused by error in `if_else()`:\n! Can't combine `true` <character> and `false` <integer>.\n```\n:::\n:::\n\n\n\nエラーメッセージで、falseはcharacterベクトルでないといけませんと怒られました。なので、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  mutate(result = if_else(num >= 5, cond1, as.character(cond2)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 4\n     num cond1 cond2 result\n   <int> <chr> <int> <chr> \n 1     1 a         1 1     \n 2     2 b         2 2     \n 3     3 c         3 3     \n 4     4 d         4 4     \n 5     5 e         5 e     \n 6     6 f         6 f     \n 7     7 g         7 g     \n 8     8 h         8 h     \n 9     9 i         9 i     \n10    10 j        10 j     \n```\n:::\n:::\n\n\n\nの様に、明確に同じ型にそろえてあげる必要があります。自動変換してくれてもよさそうに感じるかもしれませんが、自動変換のせいでデータが勝手に欠損したりする可能性もあるため、この動作の方が正解です。\n\nこの同じ型ルールで、生じる問題でもう一つ代表的なものが欠損値が生じた場合の取り扱いです。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- tibble(num=c(1,2,3,4))\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 1\n    num\n  <dbl>\n1     1\n2     2\n3     3\n4     4\n```\n:::\n:::\n\n\n\n例えば、このデータでnum列が1以外の時は欠損させたい場合、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% mutate(kekka = if_else(num==1,1,NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n    num kekka\n  <dbl> <dbl>\n1     1     1\n2     2    NA\n3     3    NA\n4     4    NA\n```\n:::\n:::\n\n\n\nと書くと、エラーが生じます。\n\nこれは、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n:::\n\n\n\nがロジカルなため、if_elseの条件で数値型のTrueの場合と型が合致しなかったから生じているエラーです。\n\nこれを回避する方法、簡単なのですが、知らないとてこづります。実は、NAには文字列型のNA,数値型のNAなどと、型に対応するNAが用意されているので、それを利用すれば解決です。具体的には、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(NA_character_)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(NA_complex_)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"complex\"\n```\n:::\n\n```{.r .cell-code}\nclass(NA_integer_)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nclass(NA_real_)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n\nを利用してあげればOKです。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% mutate(kekka = if_else(num==1,1,NA_real_))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n    num kekka\n  <dbl> <dbl>\n1     1     1\n2     2    NA\n3     3    NA\n4     4    NA\n```\n:::\n:::\n\n\n\nうまくいきましたね?\n\n以上,if_elseの基本的な使い方でした。\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}