{
  "hash": "23b3c3fa7f54056e288650a2871425c2",
  "result": {
    "markdown": "---\ntitle: 実践 str_detectとfilter\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\nそれではだいぶ間があきましたがfilter関数で文字列をひっかけるための処理をここで実践していきましょう\n\nfilter関数の練習問題の最後で解説した内容を改めてここで記載します。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp <- tibble(\n  name = c(\"apple\",\"apricot\",\"banana\",\"cherry\"),\n  price = c(120,200,98,300)\n)\ntemp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  name    price\n  <chr>   <dbl>\n1 apple     120\n2 apricot   200\n3 banana     98\n4 cherry    300\n```\n:::\n:::\n\n\n\nで、aで始まるname列のみに絞りこみたい、aで終わるname列のみに絞りこみたいという場合はどうしたらよいでしょうか？\n\nここまで学んでいただいた内容からは、\n\n* 列の絞りこみにはfilter関数を利用する。\n* filter関数の中に与えるロジカルベクトルをstr_detectで作成する\n* str_detectの中の正規表現を絞り込みたい条件に沿って作成する\n\nという3つのステップを違和感なく理解することができるはずです。\n\nこの3つのステップをスクリプトで記載すると\n\naで始まる行のみに絞り込む:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp %>% filter( str_detect(name,\"^a\") )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  name    price\n  <chr>   <dbl>\n1 apple     120\n2 apricot   200\n```\n:::\n:::\n\n\n\naで終わる行のみに絞り込む\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp %>% filter( str_detect(name, \"a$\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  name   price\n  <chr>  <dbl>\n1 banana    98\n```\n:::\n:::\n\n\n\nです。\n\n他の活用例も確認しておきましょう。\n\nstr_detectを使うと、数字のはずなのに、文字列が混ざっているような行を見つけることも簡単です。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp2 <-\n   tibble(\n     kensa = c(\"a\",\"a\",\"b\",\"b\",\"c\",\"c\"),\n     value = c(100,200,\"3OO\",\"400\",\"未\",\"500\")\n   )\n\ntemp2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  kensa value\n  <chr> <chr>\n1 a     100  \n2 a     200  \n3 b     3OO  \n4 b     400  \n5 c     未   \n6 c     500  \n```\n:::\n:::\n\n\n\nこんなデータがあったとして、仮にこれが数万行のデータで、手入力されたものであった場合、入力時点での規制がかけられていない場合、多くの場合に、「想定外」のものが紛れ込んでいます。\n\n本来、valueの列には数字しか入っていてほしくないはずなのですが、本当にそうか確認したい場合、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp2 %>%  filter( str_detect(value, \"^\\\\d+$\") )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  kensa value\n  <chr> <chr>\n1 a     100  \n2 a     200  \n3 b     400  \n4 c     500  \n```\n:::\n:::\n\n\n\nそうあってほしい正規表現をかくとこのように数字ではじまり、数字でおわり、数字以外の文字列がない行を拾うことができます。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n!c(TRUE,FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE\n```\n:::\n:::\n\n\n\nで、TRUEとFALSEを逆にできること、覚えていますか？\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n str_detect(c(\"ab\",\"ba\",\"bb\"),\"^a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n!str_detect(c(\"ab\",\"ba\",\"bb\"),\"^a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE\n```\n:::\n:::\n\n\n\nこのように、str_detectはロジカルベクトルを返すので前に!をつけることで結果をひっくり返すことができます。なので、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n temp2 %>%  filter( !str_detect(value, \"^\\\\d+$\") ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  kensa value\n  <chr> <chr>\n1 b     3OO  \n2 c     未   \n```\n:::\n:::\n\n\n\nこんな感じで、「!そうあってほしい」結果をfilter関数の中に投入すると、実は「3オーオー」と「未」という数字以外の結果が紛れていることが判明します。\n\n他にも、汚いデータの処理で注意が必要なのが全角数字の処理です。\n\n全角数字は、\\\\d+では認識されてしまうのですが\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"１２３４\",\"\\\\d+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <１２３４>\n```\n:::\n\n```{.r .cell-code}\nstr_detect(\"１２３４\",\"\\\\d+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n数値変換しようとすると失敗します\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(\"1234\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1234\n```\n:::\n\n```{.r .cell-code}\nas.numeric(\"１２３４\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n\nなので全角数字が混じっている可能性があるデータなのであれば、\\\\d+よりも、[0-9]と書いてあげる方が適切です。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(\"１２３４\",\"[0-9]\")\nstr_detect(\"１２３４\",\"[0-9]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nstr_view(\"１２３４\",\"[０-９]+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <１２３４>\n```\n:::\n\n```{.r .cell-code}\ntemp3 <- tibble(\n  num = c(111,\"1１2\",213,\"13２\",323,\"43３\",445,\"４45\",358,\"8５7\",654,\"7６6\",778,\"9７8\",865,\"８67\",596,\"76９\",506,\"6０7\")\n)\n\ntemp3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 1\n   num  \n   <chr>\n 1 111  \n 2 1１2 \n 3 213  \n 4 13２ \n 5 323  \n 6 43３ \n 7 445  \n 8 ４45 \n 9 358  \n10 8５7 \n11 654  \n12 7６6 \n13 778  \n14 9７8 \n15 865  \n16 ８67 \n17 596  \n18 76９ \n19 506  \n20 6０7 \n```\n:::\n\n```{.r .cell-code}\ntemp3 %>% filter(  str_detect(num,\"^[0-9]+$\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 1\n   num  \n   <chr>\n 1 111  \n 2 213  \n 3 323  \n 4 445  \n 5 358  \n 6 654  \n 7 778  \n 8 865  \n 9 596  \n10 506  \n```\n:::\n\n```{.r .cell-code}\ntemp3 %>% filter( !str_detect(num,\"^[0-9]+$\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 1\n   num  \n   <chr>\n 1 1１2 \n 2 13２ \n 3 43３ \n 4 ４45 \n 5 8５7 \n 6 7６6 \n 7 9７8 \n 8 ８67 \n 9 76９ \n10 6０7 \n```\n:::\n:::\n\n\n\n以上、str_detectとfilterを組み合わせて利用する方法を紹介しました。\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}