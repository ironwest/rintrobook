{
  "hash": "9d445a16bce7260bbeb5d91f48f72242",
  "result": {
    "markdown": "---\ntitle: 実践 str_extract/str_replaceとmutate\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n続いて、ここではmutateとstr_関数を組み合わせる方法を考えましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(\"ast:40IU/L\",\"alt:30IU/L\",\n         \"ggt:20IU/L\",\"hba1c:4.3mg/dL\",\n         \"glu:90mg/dL\",\"BMI:23.0kg/m2\",\n         \"eGFR:60mL/min/1.73m2\")\n\nprac <- tibble(target = vec)\nprac\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 x 1\n  target              \n  <chr>               \n1 ast:40IU/L          \n2 alt:30IU/L          \n3 ggt:20IU/L          \n4 hba1c:4.3mg/dL      \n5 glu:90mg/dL         \n6 BMI:23.0kg/m2       \n7 eGFR:60mL/min/1.73m2\n```\n:::\n:::\n\n\n\nというデータがあって、正規表現を利用して、target列を、name列とvalue列にコロンを境にして取り出して新しい列を作成する場合を考えてみましょう。\n\nこれは、（スライド６２）の処理を行う場合そのままです。\n\n列を作るにはmutate関数を利用して、data %>% mutate(列名 = ベクトル)で、列が作れましたね?\n\nstr_extract関数を利用すれば、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_extract(vec,\"(?<=:)(\\\\d+\\\\.\\\\d+|\\\\d+)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"40\"   \"30\"   \"20\"   \"4.3\"  \"90\"   \"23.0\" \"60\"  \n```\n:::\n:::\n\n\n\nこのように、コロンの左側に続く（小数あるいは数字）を抽出することができました。\n\n注：\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_extract(vec,\"\\\\d+\\\\.\\\\d+|\\\\d+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"40\"   \"30\"   \"20\"   \"1\"    \"90\"   \"23.0\" \"60\"  \n```\n:::\n:::\n\n\n\nだけだと、HbA1cの1が引っかかってしまうので、不適切です\n\n後は、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_extract(vec,\"^.+(?=:)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ast\"   \"alt\"   \"ggt\"   \"hba1c\" \"glu\"   \"BMI\"   \"eGFR\" \n```\n:::\n:::\n\n\n\nとしてあげれば、先頭から、コロンまでのすべての文字列を取得することができるので検査名の出力が可能となります。\n\n抜き出す正規表現がわかればこれを、mutateに与えてあげれば良いので、結局、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprac2 <- prac %>% \n  mutate(\n    name = str_extract(target, \"^.+(?=:)\"),\n    value = str_extract(target, \"(?<=:)(\\\\d+\\\\.\\\\d+|\\\\d+)\")\n  ) \n\nprac2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 x 3\n  target               name  value\n  <chr>                <chr> <chr>\n1 ast:40IU/L           ast   40   \n2 alt:30IU/L           alt   30   \n3 ggt:20IU/L           ggt   20   \n4 hba1c:4.3mg/dL       hba1c 4.3  \n5 glu:90mg/dL          glu   90   \n6 BMI:23.0kg/m2        BMI   23.0 \n7 eGFR:60mL/min/1.73m2 eGFR  60   \n```\n:::\n:::\n\n\n\nと分割することができました。\n\nついでに単位も抜き出してみましょうただ挑戦してみていただくとわかるのですが、ここまでの範囲ではうまく単位を抜き出すことができません\n\n本コース、正規表現をマスターするのが目的ではないので、複数回加工して最終的に単位単独の形にもっていくことを目指しましょう。具体的には\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprac2 %>% \n  mutate(\n    right = str_extract(target,\"(?<=:).+$\"),\n    tani = str_replace(right, \"^(\\\\d+\\\\.\\\\d+|\\\\d+)\",\"\")\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 x 5\n  target               name  value right           tani         \n  <chr>                <chr> <chr> <chr>           <chr>        \n1 ast:40IU/L           ast   40    40IU/L          IU/L         \n2 alt:30IU/L           alt   30    30IU/L          IU/L         \n3 ggt:20IU/L           ggt   20    20IU/L          IU/L         \n4 hba1c:4.3mg/dL       hba1c 4.3   4.3mg/dL        mg/dL        \n5 glu:90mg/dL          glu   90    90mg/dL         mg/dL        \n6 BMI:23.0kg/m2        BMI   23.0  23.0kg/m2       kg/m2        \n7 eGFR:60mL/min/1.73m2 eGFR  60    60mL/min/1.73m2 mL/min/1.73m2\n```\n:::\n:::\n\n\n\nこんな感じです。\n\nまず、rightという列に、コロンの右側を抜き出してあげます\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_extract(vec,\"(?<=:).+$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"40IU/L\"          \"30IU/L\"          \"20IU/L\"          \"4.3mg/dL\"       \n[5] \"90mg/dL\"         \"23.0kg/m2\"       \"60mL/min/1.73m2\"\n```\n:::\n:::\n\n\n\nそうすると、right列は(小数あるいは整数)(単位)という形になるので、str_replace関数で(小数あるいは整数)を\"\"(空白)で置き換えてあげることで単位だけが残るという仕組みです。\n\nいかがでしょうか？\n\nここではstr_extract、str_replace関数を利用して列を作成する方法について解説いたしました。\n\nこの二つをうまく組み合わせることで文字列を含む列の作成はかなり自由にできるようになるはずです\n\n",
    "supporting": [
      "s05-040_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}