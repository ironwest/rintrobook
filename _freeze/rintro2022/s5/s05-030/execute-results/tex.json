{
  "hash": "12acd06b0077e2fd8424ac5d7f46fb0b",
  "result": {
    "markdown": "---\ntitle: filter()の練習問題\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n\n\nここでも、arrangeに引き続き、data/population.xlsxを利用しましょう。\n\n練習問題1\n\ndata/population.xlsxの「男性」シートからデータを取得してください。\n　\n練習問題2\n\n列名が数字になっているものの頭にnenを付けてください(例: `2015` -> nen2015)\n　\n練習問題3\n\n2015年の人口が1000(100万人)以上の都道府県にデータを絞りこんでください\n　\n練習問題4\n\n2017年から2018年と、2018年から2019年で連続して人口が増加している都道府県に絞り込んでください。\n\nそれでは答えを見ていきましょう。\n\n練習問題1\n\ndata/population.xlsxの「男性」シートからデータを取得してください。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n-- Attaching core tidyverse packages ------------------------ tidyverse 2.0.0 --\nv dplyr     1.1.2     v readr     2.1.4\nv forcats   1.0.0     v stringr   1.5.0\nv ggplot2   3.4.2     v tibble    3.2.1\nv lubridate 1.9.2     v tidyr     1.3.0\nv purrr     1.0.1     \n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\ni Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(readxl)\ndat <- read_excel(\"data/population.xlsx\", sheet=\"男性\")\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 47 x 7\n   都道府県名     Prefecture    `2015` `2016` `2017` `2018` `2019`\n   <chr>          <chr>          <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n 1 北海道　　　　 Hokkaido        2537   2521   2506   2489   2472\n 2 青森県　　　　 Aomori-ken       615    608    600    593    585\n 3 岩手県　　　　 Iwate-ken        616    610    604    598    592\n 4 宮城県　　　　 Miyagi-ken      1140   1139   1136   1132   1127\n 5 秋田県　　　　 Akita-ken        480    474    468    461    454\n 6 山形県　　　　 Yamagata-ken     540    536    531    526    520\n 7 福島県　　　　 Fukushima-ken    946    941    932    923    914\n 8 茨城県　　　　 Ibaraki-ken     1454   1448   1442   1435   1427\n 9 栃木県　　　　 Tochigi-ken      982    978    974    969    964\n10 群馬県　　　　 Gumma-ken        973    971    968    965    962\n# i 37 more rows\n```\n:::\n:::\n\n\n\nここは特に問題ありませんね？\n\n\n練習問題2\n\n列名が数字になっているものの頭にnenを付けてください(例: `2015` -> nen2015)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"都道府県名\" \"Prefecture\" \"2015\"       \"2016\"       \"2017\"      \n[6] \"2018\"       \"2019\"      \n```\n:::\n\n```{.r .cell-code}\ndat2 <- dat %>% \n  rename(\n    nen2015 = `2015`,\n    nen2016 = `2016`,\n    nen2017 = `2017`,\n    nen2018 = `2018`,\n    nen2019 = `2019`,\n  )\ndat2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 47 x 7\n   都道府県名     Prefecture    nen2015 nen2016 nen2017 nen2018 nen2019\n   <chr>          <chr>           <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1 北海道　　　　 Hokkaido         2537    2521    2506    2489    2472\n 2 青森県　　　　 Aomori-ken        615     608     600     593     585\n 3 岩手県　　　　 Iwate-ken         616     610     604     598     592\n 4 宮城県　　　　 Miyagi-ken       1140    1139    1136    1132    1127\n 5 秋田県　　　　 Akita-ken         480     474     468     461     454\n 6 山形県　　　　 Yamagata-ken      540     536     531     526     520\n 7 福島県　　　　 Fukushima-ken     946     941     932     923     914\n 8 茨城県　　　　 Ibaraki-ken      1454    1448    1442    1435    1427\n 9 栃木県　　　　 Tochigi-ken       982     978     974     969     964\n10 群馬県　　　　 Gumma-ken         973     971     968     965     962\n# i 37 more rows\n```\n:::\n:::\n\n\n\nこの問題はrename関数の使い方の復習です。\n\n練習問題3\n\n2015年の人口が1000(100万人)以上の都道府県にデータを絞りこんでください\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 %>% \n  filter(nen2015 >= 1000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 x 7\n   都道府県名     Prefecture    nen2015 nen2016 nen2017 nen2018 nen2019\n   <chr>          <chr>           <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1 北海道　　　　 Hokkaido         2537    2521    2506    2489    2472\n 2 宮城県　　　　 Miyagi-ken       1140    1139    1136    1132    1127\n 3 茨城県　　　　 Ibaraki-ken      1454    1448    1442    1435    1427\n 4 埼玉県　　　　 Saitama-ken      3628    3639    3648    3658    3668\n 5 千葉県　　　　 Chiba-ken        3096    3099    3103    3105    3105\n 6 東京都　　　　 Tokyo-to         6667    6717    6760    6802    6846\n 7 神奈川県　　　 Kanagawa-ken     4559    4565    4569    4576    4585\n 8 新潟県　　　　 Niigata-ken      1115    1107    1098    1088    1078\n 9 長野県　　　　 Nagano-ken       1022    1017    1012    1006    1000\n10 静岡県　　　　 Shizuoka-ken     1821    1815    1810    1803    1797\n11 愛知県　　　　 Aichi-ken        3741    3755    3764    3770    3780\n12 京都府　　　　 Kyoto-fu         1249    1246    1242    1238    1234\n13 大阪府　　　　 Osaka-fu         4256    4249    4241    4232    4227\n14 兵庫県　　　　 Hyogo-ken        2642    2633    2624    2614    2605\n15 広島県　　　　 Hiroshima-ken    1376    1375    1372    1367    1362\n16 福岡県　　　　 Fukuoka-ken      2410    2413    2415    2416    2416\n```\n:::\n:::\n\n\n\nfiterの基本的な使い方です。\n\n練習問題4\n\n2017年から2018年と、2018年から2019年で連続して人口が増加している都道府県に絞り込んでください。\n\nこの問題は少し難しいかもしれません\n\n答えは、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 %>% \n  mutate(diff1718 = nen2018 - nen2017,\n         diff1819 = nen2019 - nen2018) %>% \n  filter(diff1718 > 0 & diff1819 > 0) %>% \n  select(`都道府県名`, diff1718, diff1819)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 3\n  都道府県名     diff1718 diff1819\n  <chr>             <dbl>    <dbl>\n1 埼玉県　　　　       10       10\n2 東京都　　　　       42       44\n3 神奈川県　　　        7        9\n4 愛知県　　　　        6       10\n5 沖縄県　　　　        3        3\n```\n:::\n:::\n\n\n\nとなります。\n\nmutateで、まず各年度間の差を計算して、それをfilterで0より大きいものに絞り込んでいます最後のselectは画面に収めるためのものです。\n\nいかがでしたでしょうか?\n\nfilter関数とlogicalベクトルの組み合わせで行を絞り込む方法についてイメージはつきましたか？\n\nfilter関数、ここまで数字に基づいた絞りこみを行ってきましたが、実は文字列型に対しても絞り込みを行うこともできます。\n\n例えば\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp <- tibble(\n  name = c(\"apple\",\"apricot\",\"banana\",\"cherry\"),\n  price = c(120,200,98,300)\n)\ntemp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 2\n  name    price\n  <chr>   <dbl>\n1 apple     120\n2 apricot   200\n3 banana     98\n4 cherry    300\n```\n:::\n:::\n\n\n\nですが、appleのみの列に絞りこむなら\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp %>% filter(name == \"apple\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 2\n  name  price\n  <chr> <dbl>\n1 apple   120\n```\n:::\n:::\n\n\n\nで可能です。\n\nそれでは、aで始まるname列のみに絞りこみたいという場合はどうしたらよいでしょうか？\n\n実はそれも簡単にできて、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp %>% filter( str_detect(name,\"^a\") )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 2\n  name    price\n  <chr>   <dbl>\n1 apple     120\n2 apricot   200\n```\n:::\n:::\n\n\n\nまた、aで終わる名前に絞りこみたいであれば、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp %>% filter( str_detect(name, \"a$\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 2\n  name   price\n  <chr>  <dbl>\n1 banana    98\n```\n:::\n:::\n\n\n\nです。\n\nここでaで始まるを意味する^aやaで終わるを意味するa$のことを正規表現といいます。\n\nこの正規表現を取り扱うためにstr_detectという関数が用意されています。\n\nここからは、この正規表現について解説して、その後、str_detect等の正規表現を利用できる関数の紹介を行います。\n\nこの二つの内容を理解いただけると、\n\n文字列に対して自由にロジカル型のベクトルを設定できるようになり、文字列データを自由に絞り込んだり加工したりすることができるようになりますのでがんばってください。\n\n",
    "supporting": [
      "s05-030_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}