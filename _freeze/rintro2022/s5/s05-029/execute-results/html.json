{
  "hash": "f094a0218c605fbe7eac0bc4a89cf2b5",
  "result": {
    "markdown": "---\ntitle: filter()の実践\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n\n\nそれでは、filerを実践していきましょう。まずはtibbleを作りましょう\n \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\ndat <- tibble(a = c(1:50), b = sample(50:1))\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 × 2\n       a     b\n   <int> <int>\n 1     1    12\n 2     2    28\n 3     3    27\n 4     4     2\n 5     5    26\n 6     6    13\n 7     7    25\n 8     8    36\n 9     9    37\n10    10    35\n# ℹ 40 more rows\n```\n:::\n:::\n\n\n\nまず、a列が15であるものをとりだします\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% filter(a == 15)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n      a     b\n  <int> <int>\n1    15    10\n```\n:::\n:::\n\n\n\na列が15あるいはb列が30以上の行をとりだせますか？\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% filter(a == 15 | b >= 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 22 × 2\n       a     b\n   <int> <int>\n 1     8    36\n 2     9    37\n 3    10    35\n 4    12    48\n 5    14    45\n 6    15    10\n 7    18    33\n 8    19    42\n 9    20    30\n10    23    38\n# ℹ 12 more rows\n```\n:::\n:::\n\n\n\nロジカル型の練習問題ででてきた書き方を応用すれば、\n\na列が2の倍数となる行は\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% filter(a %% 2 == 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 × 2\n       a     b\n   <int> <int>\n 1     2    28\n 2     4     2\n 3     6    13\n 4     8    36\n 5    10    35\n 6    12    48\n 7    14    45\n 8    16    20\n 9    18    33\n10    20    30\n# ℹ 15 more rows\n```\n:::\n:::\n\n\n\nb列が2の倍数となる行は\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% filter(b %% 2 == 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 × 2\n       a     b\n   <int> <int>\n 1     1    12\n 2     2    28\n 3     4     2\n 4     5    26\n 5     8    36\n 6    12    48\n 7    13    22\n 8    15    10\n 9    16    20\n10    19    42\n# ℹ 15 more rows\n```\n:::\n:::\n\n\n\nこんな感じで列をTRUE、FALSEのベクトルを利用して抽出することができます。\n\nまた、もちろん、文字列型の列に対しても同じように操作ができて、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- tibble(\n  num = 1:10,\n  chr = c(\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\",\"a\",\"b\",\"c\")\n)\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n     num chr  \n   <int> <chr>\n 1     1 a    \n 2     2 a    \n 3     3 b    \n 4     4 b    \n 5     5 c    \n 6     6 c    \n 7     7 c    \n 8     8 a    \n 9     9 b    \n10    10 c    \n```\n:::\n\n```{.r .cell-code}\ndat %>% filter(chr == \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n    num chr  \n  <int> <chr>\n1     1 a    \n2     2 a    \n3     8 a    \n```\n:::\n:::\n\n\n\nとすることによって文字列を条件づけて行をとりだすことができます。\n\nここで、aとcを取り出したい場合は、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% filter(chr == c(\"a\",\"c\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n    num chr  \n  <int> <chr>\n1     1 a    \n2     6 c    \n3    10 c    \n```\n:::\n:::\n\n\n\nとすると実は誤っているので注意が必要です。なぜなら、\n```\ndat$chr   : \"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\",\"a\",\"b\",\"c\"\nc(\"a\",\"c\"): \"a\",\"c\",\"a\",\"c\",\"a\",\"c\",\"a\",\"c\",\"a\",\"c\", \n             T   F   F   F   F   T   F   F   F   T\n```\n\nこんな感じで繰り返されたTRUE,FALSEが返ってくると解されるからです。\n\nここで、複数条件で絞り込む場合は、すこし特殊な、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% filter(chr %in% c(\"a\",\"c\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 2\n    num chr  \n  <int> <chr>\n1     1 a    \n2     2 a    \n3     5 c    \n4     6 c    \n5     7 c    \n6     8 a    \n7    10 c    \n```\n:::\n:::\n\n\n\n%in% 記号というものを利用します。この記号を利用することで、\n\n```\ndat$chr   : \"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\",\"a\",\"b\",\"c\"\n\nc(\"a\",\"c\"): \"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"\n　　　　　　\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\"\n             T   T   F   F   T   T   F   T   F   T\n```\n\n両方のどちらかと一致する形になります。もちろん、｜演算子を利用して、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% filter(chr == \"a\" | chr == \"c\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 2\n    num chr  \n  <int> <chr>\n1     1 a    \n2     2 a    \n3     5 c    \n4     6 c    \n5     7 c    \n6     8 a    \n7    10 c    \n```\n:::\n:::\n\n\n\nと書いても同じ結果になりますが、 %in% の書き方を知っていると楽なので、ここで紹介しました。\n\nそれでは、filter関数の練習問題に進んでいきましょう。\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}