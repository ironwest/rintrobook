{
  "hash": "2dae568d20a7055e4797cc5e989c92ab",
  "result": {
    "markdown": "---\ntitle: Rmarkdownでレポートを作成してみる―課題2\npage-layout: full\ntitle-block-banner: true\ncomments: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(gtsummary)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'gtsummary' was built under R version 4.3.2\n```\n:::\n\n```{.r .cell-code}\nmake_hyou <- function(.data){\n  .data %>% \n    tbl_summary(\n      data = .,\n      by=\"yr\",\n      include = c(\"bmi\",\"sbp\",\"dbp\"),\n      label = list(bmi ~ \"BMI\", \n                   sbp ~ \"収縮期血圧\",\n                   dbp ~ \"拡張期血圧\") \n    ) %>% \n    modify_header(list(label~\"**検査値**\")) %>%  \n    # 検査値を足しています\n    \n    modify_spanning_header( #この関数で「年度」を足しています\n      list(\n        stat_1 ~ \"**年度**\",\n        stat_2 ~ \"**年度**\",\n        stat_3 ~ \"**年度**\"\n      )\n    ) %>% \n    \n    modify_footnote( # この関数でフットノートを日本語にしています\n      list(\n        stat_1 ~ \"中央値(IQR)\",\n        stat_2 ~ \"中央値(IQR)\",\n        stat_3 ~ \"中央値(IQR)\"\n      )\n    )\n}\n\ndat <- read_csv(\"kadai/data/data.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 2460 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (6): wpid, id, yr, bmi, sbp, dbp\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\ntbl2 <- tbl_summary(\n  data = dat,\n  by=\"yr\",\n  include = c(\"bmi\",\"sbp\",\"dbp\"),\n  label = list(bmi ~ \"BMI\", \n               sbp ~ \"収縮期血圧\",\n               dbp ~ \"拡張期血圧\") \n) %>% \n  modify_header(list(label~\"**検査値**\")) %>%  \n  　　　# 検査値を足しています\n  \n  modify_spanning_header( #この関数で「年度」を足しています\n    list(\n      stat_1 ~ \"**年度**\",\n      stat_2 ~ \"**年度**\",\n      stat_3 ~ \"**年度**\"\n    )\n  ) %>% \n  \n  modify_footnote( # この関数でフットノートを日本語にしています\n    list(\n      stat_1 ~ \"中央値(IQR)\",\n      stat_2 ~ \"中央値(IQR)\",\n      stat_3 ~ \"中央値(IQR)\"\n    )\n  )\n```\n:::\n\n\n\n課題2：\n　　\n次に、職場別に集計して上司にプレゼンした結果、ここの職場の担当者にも結果を送ってほしいと上司からいわれました。会社は伝統的にデータのやりとりはエクセルファイルで行われています。\n　　\n課題１の集計結果を、それなりに見栄えのする表を作って各職場の担当者に送信するためのエクセルファイルを職場の数だけ作成してみてください。\n　　\nこの課題、xlsxに、gtsummary::tbl_summaryの結果を入れることができれば解決します。tbl_summaryの結果を取り出して、表に入れられるように加工します。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbody <- tbl2$table_body\ntby   <- tbl2$df_by\n```\n:::\n\n\n\ntbodyは、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbody2 <- tbody %>% \n  select(label, starts_with(\"stat_\"))\n\ntbody2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 4\n  label      stat_1               stat_2               stat_3              \n  <chr>      <chr>                <chr>                <chr>               \n1 BMI        22.34 (21.33, 23.52) 22.35 (21.29, 23.51) 22.42 (21.28, 23.40)\n2 収縮期血圧 92 (82, 140)         92 (82, 140)         92 (82, 140)        \n3 拡張期血圧 34 (24, 82)          34 (24, 82)          33 (24, 82)         \n```\n:::\n:::\n\n\n\nを、そのまま入れてあげるとよさそうです。\n\n後は、列名を何とかしてあげたいですが結果で、人数行を作りつつ名前を置き換えるとすると、\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nninzu <- tby$n %>% as.character()\nnendo <- tby$by_chr\n\nwriteall <- tbody2 %>% \n  add_row(tibble(label = \"人数\",\n                 stat_1 = ninzu[1],\n                 stat_2 = ninzu[2],\n                 stat_3 = ninzu[3]), .before = 1) %>% \n  setNames(c(\" \", nendo))\n```\n:::\n\n\n\nこんな処理をすることで、表ができあがりました。\n\nここで、これまで紹介していない関数としてadd_rowがあります。これは、tibbleに対して、好きな内容の行を追加するという関数で、位置も指定可能です。\n\nあと、setNamesで名前を変換してあげると出来上がりです。\n\n繰り返しですが、この課題、「Rでこんなこともできる」ということを例示するためのものなので、この回答が思いつかなくてもこのコースを１度みただけの方であれば問題ないと思います。気楽に見てください。\n\nwpid1-5も関数を利用して作成しておきます\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_table_for_excel <- function(gttbl){\n  tbody <- gttbl$table_body\n  tby   <- gttbl$df_by\n  \n  tbody2 <- tbody %>% \n    select(label, starts_with(\"stat_\"))\n  \n  ninzu <- tby$n %>% as.character()\n  nendo <- tby$by_chr\n  \n  res <- tbody2 %>% \n    add_row(tibble(label = \"人数\",\n                   stat_1 = ninzu[1],\n                   stat_2 = ninzu[2],\n                   stat_3 = ninzu[3]), .before = 1) %>% \n    setNames(c(\" \", nendo))\n  \n  return(res)\n}\n\ntblall <- dat %>% make_hyou() %>% make_table_for_excel()\ntblp1 <- dat %>% filter(wpid==1) %>% make_hyou() %>% make_table_for_excel()\ntblp2 <- dat %>% filter(wpid==2) %>% make_hyou() %>% make_table_for_excel()\ntblp3 <- dat %>% filter(wpid==3) %>% make_hyou() %>% make_table_for_excel()\ntblp4 <- dat %>% filter(wpid==4) %>% make_hyou() %>% make_table_for_excel()\ntblp5 <- dat %>% filter(wpid==5) %>% make_hyou() %>% make_table_for_excel()\n```\n:::\n\n\n\nこの結果を、次にxlsxファイルに書き込んでみましょう。\n\nここではopenxlsxを利用します。\n\nwpid1へのエクセルファイル\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstyle <- openxlsx::createStyle(\n  border = c(\"top\", \"bottom\", \"left\", \"right\")\n)\n\nwb <- openxlsx::createWorkbook()\nopenxlsx::addWorksheet(wb,\"wpid1\")\nopenxlsx::writeData(wb,sheet=\"wpid1\",x=\"全体\" ,startCol=1,startRow=1)\nopenxlsx::writeData(wb,sheet=\"wpid1\",x=tblall ,startCol=2,startRow=2)\nopenxlsx::writeData(wb,sheet=\"wpid1\",x=\"WPID1\",startCol=1,startRow=7)\nopenxlsx::writeData(wb,sheet=\"wpid1\",x=tblp1  ,startCol=2,startRow=8)\nopenxlsx::addStyle(wb,\"wpid1\",rows=c(2:6),cols=c(2:5), style=style, gridExpand = TRUE)\nopenxlsx::addStyle(wb,\"wpid1\",rows=c(8:12),cols=c(2:5), style=style, gridExpand = TRUE)\nopenxlsx::setColWidths(wb,\"wpid1\",cols=c(2:5),widths=\"auto\")\nopenxlsx::saveWorkbook(wb,\"kadai/forwpid1.xlsx\",overwrite = TRUE)\n```\n:::\n\n\n\nうまくいきましたね？\n\nあとはこれを関数化しましょう。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_excel_file <- function(excel_data, wpid=1){\n  style <- openxlsx::createStyle(\n    border = c(\"top\", \"bottom\", \"left\", \"right\")\n  )\n  \n  wptext <- str_c(\"wpid\",wpid)\n  \n  wb <- openxlsx::createWorkbook()\n  openxlsx::addWorksheet(wb,wptext)\n  openxlsx::writeData(wb,sheet=wptext,x=\"全体\" ,startCol=1,startRow=1)\n  openxlsx::writeData(wb,sheet=wptext,x=tblall ,startCol=2,startRow=2)\n  openxlsx::writeData(wb,sheet=wptext,x=wptext,startCol=1,startRow=7)\n  openxlsx::writeData(wb,sheet=wptext,x=tblp1  ,startCol=2,startRow=8)\n  openxlsx::addStyle(wb,wptext,rows=c(2:6),cols=c(2:5), style=style, gridExpand = TRUE)\n  openxlsx::addStyle(wb,wptext,rows=c(8:12),cols=c(2:5), style=style, gridExpand = TRUE)\n  openxlsx::setColWidths(wb,wptext,cols=c(2:5),widths=\"auto\")\n  openxlsx::saveWorkbook(wb, str_glue(\"kadai/for{wptext}.xlsx\"),overwrite = TRUE)\n}\n```\n:::\n\n\n\nこの関数を利用して、エクセルファイルを事業場毎（wpid毎）に、作成します。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% filter(wpid==1) %>% make_hyou() %>% make_table_for_excel() %>% make_excel_file(wpid=1)\ndat %>% filter(wpid==2) %>% make_hyou() %>% make_table_for_excel() %>% make_excel_file(wpid=2)\ndat %>% filter(wpid==3) %>% make_hyou() %>% make_table_for_excel() %>% make_excel_file(wpid=3)\ndat %>% filter(wpid==4) %>% make_hyou() %>% make_table_for_excel() %>% make_excel_file(wpid=4)\ndat %>% filter(wpid==5) %>% make_hyou() %>% make_table_for_excel() %>% make_excel_file(wpid=5)\n```\n:::\n\n\nできましたね？今回、作成するファイルは５こですが、これが２０個とか１００個とかになると、R（プログラム）を介してファイル作成するメリットが感じられるようになるはずです。",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}